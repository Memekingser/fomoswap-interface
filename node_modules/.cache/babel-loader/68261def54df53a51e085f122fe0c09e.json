{"ast":null,"code":"import { currencyEquals, ETHER, WETH } from 'fomoswap-bera1';\nimport { useMemo } from 'react';\nimport { tryParseAmount } from '../state/swap/hooks';\nimport { useTransactionAdder } from '../state/transactions/hooks';\nimport { useCurrencyBalance } from '../state/wallet/hooks';\nimport { useActiveWeb3React } from './index';\nimport { useWETHContract } from './useContract';\nexport let WrapType;\n(function (WrapType) {\n  WrapType[WrapType[\"NOT_APPLICABLE\"] = 0] = \"NOT_APPLICABLE\";\n  WrapType[WrapType[\"WRAP\"] = 1] = \"WRAP\";\n  WrapType[WrapType[\"UNWRAP\"] = 2] = \"UNWRAP\";\n})(WrapType || (WrapType = {}));\nconst NOT_APPLICABLE = {\n  wrapType: WrapType.NOT_APPLICABLE\n};\n/**\n * Given the selected input and output currency, return a wrap callback\n * @param inputCurrency the selected input currency\n * @param outputCurrency the selected output currency\n * @param typedValue the user input value\n */\nexport default function useWrapCallback(inputCurrency, outputCurrency, typedValue) {\n  const {\n    chainId,\n    account\n  } = useActiveWeb3React();\n  const wethContract = useWETHContract();\n  const balance = useCurrencyBalance(account !== null && account !== void 0 ? account : undefined, inputCurrency);\n  // we can always parse the amount typed as the input currency, since wrapping is 1:1\n  const inputAmount = useMemo(() => tryParseAmount(typedValue, inputCurrency), [inputCurrency, typedValue]);\n  const addTransaction = useTransactionAdder();\n  return useMemo(() => {\n    if (!wethContract || !chainId || !inputCurrency || !outputCurrency) return NOT_APPLICABLE;\n    const sufficientBalance = inputAmount && balance && !balance.lessThan(inputAmount);\n    if (inputCurrency === ETHER && currencyEquals(WETH[chainId], outputCurrency)) {\n      return {\n        wrapType: WrapType.WRAP,\n        execute: sufficientBalance && inputAmount ? async () => {\n          try {\n            const txReceipt = await wethContract.deposit({\n              value: `0x${inputAmount.raw.toString(16)}`\n            });\n            addTransaction(txReceipt, {\n              summary: `Wrap ${inputAmount.toSignificant(6)} ETH to WETH`\n            });\n          } catch (error) {\n            console.error('Could not deposit', error);\n          }\n        } : undefined,\n        inputError: sufficientBalance ? undefined : 'Insufficient ETH balance'\n      };\n    } else if (currencyEquals(WETH[chainId], inputCurrency) && outputCurrency === ETHER) {\n      return {\n        wrapType: WrapType.UNWRAP,\n        execute: sufficientBalance && inputAmount ? async () => {\n          try {\n            const txReceipt = await wethContract.withdraw(`0x${inputAmount.raw.toString(16)}`);\n            addTransaction(txReceipt, {\n              summary: `Unwrap ${inputAmount.toSignificant(6)} WETH to ETH`\n            });\n          } catch (error) {\n            console.error('Could not withdraw', error);\n          }\n        } : undefined,\n        inputError: sufficientBalance ? undefined : 'Insufficient WETH balance'\n      };\n    } else {\n      return NOT_APPLICABLE;\n    }\n  }, [wethContract, chainId, inputCurrency, outputCurrency, inputAmount, balance, addTransaction]);\n}","map":{"version":3,"names":["currencyEquals","ETHER","WETH","useMemo","tryParseAmount","useTransactionAdder","useCurrencyBalance","useActiveWeb3React","useWETHContract","WrapType","NOT_APPLICABLE","wrapType","useWrapCallback","inputCurrency","outputCurrency","typedValue","chainId","account","wethContract","balance","undefined","inputAmount","addTransaction","sufficientBalance","lessThan","WRAP","execute","txReceipt","deposit","value","raw","toString","summary","toSignificant","error","console","inputError","UNWRAP","withdraw"],"sources":["/Users/synallage/Desktop/fomoswap-uni/interface-73580de922ce3ff642430d71aa24f5c053e6dd4d/src/hooks/useWrapCallback.ts"],"sourcesContent":["import { Currency, currencyEquals, ETHER, WETH } from 'fomoswap-bera1'\nimport { useMemo } from 'react'\nimport { tryParseAmount } from '../state/swap/hooks'\nimport { useTransactionAdder } from '../state/transactions/hooks'\nimport { useCurrencyBalance } from '../state/wallet/hooks'\nimport { useActiveWeb3React } from './index'\nimport { useWETHContract } from './useContract'\n\nexport enum WrapType {\n  NOT_APPLICABLE,\n  WRAP,\n  UNWRAP\n}\n\nconst NOT_APPLICABLE = { wrapType: WrapType.NOT_APPLICABLE }\n/**\n * Given the selected input and output currency, return a wrap callback\n * @param inputCurrency the selected input currency\n * @param outputCurrency the selected output currency\n * @param typedValue the user input value\n */\nexport default function useWrapCallback(\n  inputCurrency: Currency | undefined,\n  outputCurrency: Currency | undefined,\n  typedValue: string | undefined\n): { wrapType: WrapType; execute?: undefined | (() => Promise<void>); inputError?: string } {\n  const { chainId, account } = useActiveWeb3React()\n  const wethContract = useWETHContract()\n  const balance = useCurrencyBalance(account ?? undefined, inputCurrency)\n  // we can always parse the amount typed as the input currency, since wrapping is 1:1\n  const inputAmount = useMemo(() => tryParseAmount(typedValue, inputCurrency), [inputCurrency, typedValue])\n  const addTransaction = useTransactionAdder()\n\n  return useMemo(() => {\n    if (!wethContract || !chainId || !inputCurrency || !outputCurrency) return NOT_APPLICABLE\n\n    const sufficientBalance = inputAmount && balance && !balance.lessThan(inputAmount)\n\n    if (inputCurrency === ETHER && currencyEquals(WETH[chainId], outputCurrency)) {\n      return {\n        wrapType: WrapType.WRAP,\n        execute:\n          sufficientBalance && inputAmount\n            ? async () => {\n                try {\n                  const txReceipt = await wethContract.deposit({ value: `0x${inputAmount.raw.toString(16)}` })\n                  addTransaction(txReceipt, { summary: `Wrap ${inputAmount.toSignificant(6)} ETH to WETH` })\n                } catch (error) {\n                  console.error('Could not deposit', error)\n                }\n              }\n            : undefined,\n        inputError: sufficientBalance ? undefined : 'Insufficient ETH balance'\n      }\n    } else if (currencyEquals(WETH[chainId], inputCurrency) && outputCurrency === ETHER) {\n      return {\n        wrapType: WrapType.UNWRAP,\n        execute:\n          sufficientBalance && inputAmount\n            ? async () => {\n                try {\n                  const txReceipt = await wethContract.withdraw(`0x${inputAmount.raw.toString(16)}`)\n                  addTransaction(txReceipt, { summary: `Unwrap ${inputAmount.toSignificant(6)} WETH to ETH` })\n                } catch (error) {\n                  console.error('Could not withdraw', error)\n                }\n              }\n            : undefined,\n        inputError: sufficientBalance ? undefined : 'Insufficient WETH balance'\n      }\n    } else {\n      return NOT_APPLICABLE\n    }\n  }, [wethContract, chainId, inputCurrency, outputCurrency, inputAmount, balance, addTransaction])\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}