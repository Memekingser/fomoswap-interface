{"ast":null,"code":"import { Pair, Token } from 'fomoswap-bera1';\nimport flatMap from 'lodash.flatmap';\nimport { useCallback, useMemo } from 'react';\nimport { shallowEqual, useDispatch, useSelector } from 'react-redux';\nimport { BASES_TO_TRACK_LIQUIDITY_FOR, PINNED_PAIRS } from '../../constants';\nimport { useActiveWeb3React } from '../../hooks';\nimport { useAllTokens } from '../../hooks/Tokens';\nimport { addSerializedPair, addSerializedToken, dismissTokenWarning, removeSerializedToken, updateUserDarkMode, updateUserDeadline, updateUserExpertMode, updateUserSlippageTolerance } from './actions';\nimport { useDefaultTokenList } from '../lists/hooks';\nimport { isDefaultToken } from '../../utils';\nfunction serializeToken(token) {\n  return {\n    chainId: token.chainId,\n    address: token.address,\n    decimals: token.decimals,\n    symbol: token.symbol,\n    name: token.name\n  };\n}\nfunction deserializeToken(serializedToken) {\n  return new Token(serializedToken.chainId, serializedToken.address, serializedToken.decimals, serializedToken.symbol, serializedToken.name);\n}\nexport function useIsDarkMode() {\n  const {\n    userDarkMode,\n    matchesDarkMode\n  } = useSelector(({\n    user: {\n      matchesDarkMode,\n      userDarkMode\n    }\n  }) => ({\n    userDarkMode,\n    matchesDarkMode\n  }), shallowEqual);\n  return userDarkMode === null ? matchesDarkMode : userDarkMode;\n}\nexport function useDarkModeManager() {\n  const dispatch = useDispatch();\n  const darkMode = useIsDarkMode();\n  const toggleSetDarkMode = useCallback(() => {\n    dispatch(updateUserDarkMode({\n      userDarkMode: !darkMode\n    }));\n  }, [darkMode, dispatch]);\n  return [darkMode, toggleSetDarkMode];\n}\nexport function useIsExpertMode() {\n  return useSelector(state => state.user.userExpertMode);\n}\nexport function useExpertModeManager() {\n  const dispatch = useDispatch();\n  const expertMode = useIsExpertMode();\n  const toggleSetExpertMode = useCallback(() => {\n    dispatch(updateUserExpertMode({\n      userExpertMode: !expertMode\n    }));\n  }, [expertMode, dispatch]);\n  return [expertMode, toggleSetExpertMode];\n}\nexport function useUserSlippageTolerance() {\n  const dispatch = useDispatch();\n  const userSlippageTolerance = useSelector(state => {\n    return state.user.userSlippageTolerance;\n  });\n  const setUserSlippageTolerance = useCallback(userSlippageTolerance => {\n    dispatch(updateUserSlippageTolerance({\n      userSlippageTolerance\n    }));\n  }, [dispatch]);\n  return [userSlippageTolerance, setUserSlippageTolerance];\n}\nexport function useUserDeadline() {\n  const dispatch = useDispatch();\n  const userDeadline = useSelector(state => {\n    return state.user.userDeadline;\n  });\n  const setUserDeadline = useCallback(userDeadline => {\n    dispatch(updateUserDeadline({\n      userDeadline\n    }));\n  }, [dispatch]);\n  return [userDeadline, setUserDeadline];\n}\nexport function useAddUserToken() {\n  const dispatch = useDispatch();\n  return useCallback(token => {\n    dispatch(addSerializedToken({\n      serializedToken: serializeToken(token)\n    }));\n  }, [dispatch]);\n}\nexport function useRemoveUserAddedToken() {\n  const dispatch = useDispatch();\n  return useCallback((chainId, address) => {\n    dispatch(removeSerializedToken({\n      chainId,\n      address\n    }));\n  }, [dispatch]);\n}\nexport function useUserAddedTokens() {\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const serializedTokensMap = useSelector(({\n    user: {\n      tokens\n    }\n  }) => tokens);\n  return useMemo(() => {\n    var _serializedTokensMap;\n    if (!chainId) return [];\n    return Object.values((_serializedTokensMap = serializedTokensMap[chainId]) !== null && _serializedTokensMap !== void 0 ? _serializedTokensMap : {}).map(deserializeToken);\n  }, [serializedTokensMap, chainId]);\n}\nfunction serializePair(pair) {\n  return {\n    token0: serializeToken(pair.token0),\n    token1: serializeToken(pair.token1)\n  };\n}\nexport function usePairAdder() {\n  const dispatch = useDispatch();\n  return useCallback(pair => {\n    dispatch(addSerializedPair({\n      serializedPair: serializePair(pair)\n    }));\n  }, [dispatch]);\n}\n\n/**\n * Returns whether a token warning has been dismissed and a callback to dismiss it,\n * iff it has not already been dismissed and is a valid token.\n */\nexport function useTokenWarningDismissal(chainId, token) {\n  const dismissalState = useSelector(state => state.user.dismissedTokenWarnings);\n  const dispatch = useDispatch();\n\n  // get default list, mark as dismissed if on list\n  const defaultList = useDefaultTokenList();\n  const isDefault = isDefaultToken(defaultList, token);\n  return useMemo(() => {\n    var _dismissalState$chain;\n    if (!chainId || !token) return [false, null];\n    const dismissed = token instanceof Token ? (dismissalState === null || dismissalState === void 0 ? void 0 : (_dismissalState$chain = dismissalState[chainId]) === null || _dismissalState$chain === void 0 ? void 0 : _dismissalState$chain[token.address]) === true || isDefault : true;\n    const callback = dismissed || !(token instanceof Token) ? null : () => dispatch(dismissTokenWarning({\n      chainId,\n      tokenAddress: token.address\n    }));\n    return [dismissed, callback];\n  }, [chainId, token, dismissalState, isDefault, dispatch]);\n}\n\n/**\n * Given two tokens return the liquidity token that represents its liquidity shares\n * @param tokenA one of the two tokens\n * @param tokenB the other token\n */\nexport function toV2LiquidityToken([tokenA, tokenB]) {\n  return new Token(tokenA.chainId, Pair.getAddress(tokenA, tokenB), 18, 'UNI-V2', 'Uniswap V2');\n}\n\n/**\n * Returns all the pairs of tokens that are tracked by the user for the current chain ID.\n */\nexport function useTrackedTokenPairs() {\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const tokens = useAllTokens();\n\n  // pinned pairs\n  const pinnedPairs = useMemo(() => {\n    var _PINNED_PAIRS$chainId;\n    return chainId ? (_PINNED_PAIRS$chainId = PINNED_PAIRS[chainId]) !== null && _PINNED_PAIRS$chainId !== void 0 ? _PINNED_PAIRS$chainId : [] : [];\n  }, [chainId]);\n\n  // pairs for every token against every base\n  const generatedPairs = useMemo(() => chainId ? flatMap(Object.keys(tokens), tokenAddress => {\n    var _BASES_TO_TRACK_LIQUI;\n    const token = tokens[tokenAddress];\n    // for each token on the current chain,\n    return (\n      // loop though all bases on the current chain\n      ((_BASES_TO_TRACK_LIQUI = BASES_TO_TRACK_LIQUIDITY_FOR[chainId]) !== null && _BASES_TO_TRACK_LIQUI !== void 0 ? _BASES_TO_TRACK_LIQUI : [] // to construct pairs of the given token with each base\n      ).map(base => {\n        if (base.address === token.address) {\n          return null;\n        } else {\n          return [base, token];\n        }\n      }).filter(p => p !== null)\n    );\n  }) : [], [tokens, chainId]);\n\n  // pairs saved by users\n  const savedSerializedPairs = useSelector(({\n    user: {\n      pairs\n    }\n  }) => pairs);\n  const userPairs = useMemo(() => {\n    if (!chainId || !savedSerializedPairs) return [];\n    const forChain = savedSerializedPairs[chainId];\n    if (!forChain) return [];\n    return Object.keys(forChain).map(pairId => {\n      return [deserializeToken(forChain[pairId].token0), deserializeToken(forChain[pairId].token1)];\n    });\n  }, [savedSerializedPairs, chainId]);\n  const combinedList = useMemo(() => userPairs.concat(generatedPairs).concat(pinnedPairs), [generatedPairs, pinnedPairs, userPairs]);\n  return useMemo(() => {\n    // dedupes pairs of tokens in the combined list\n    const keyed = combinedList.reduce((memo, [tokenA, tokenB]) => {\n      const sorted = tokenA.sortsBefore(tokenB);\n      const key = sorted ? `${tokenA.address}:${tokenB.address}` : `${tokenB.address}:${tokenA.address}`;\n      if (memo[key]) return memo;\n      memo[key] = sorted ? [tokenA, tokenB] : [tokenB, tokenA];\n      return memo;\n    }, {});\n    return Object.keys(keyed).map(key => keyed[key]);\n  }, [combinedList]);\n}","map":{"version":3,"names":["Pair","Token","flatMap","useCallback","useMemo","shallowEqual","useDispatch","useSelector","BASES_TO_TRACK_LIQUIDITY_FOR","PINNED_PAIRS","useActiveWeb3React","useAllTokens","addSerializedPair","addSerializedToken","dismissTokenWarning","removeSerializedToken","updateUserDarkMode","updateUserDeadline","updateUserExpertMode","updateUserSlippageTolerance","useDefaultTokenList","isDefaultToken","serializeToken","token","chainId","address","decimals","symbol","name","deserializeToken","serializedToken","useIsDarkMode","userDarkMode","matchesDarkMode","user","useDarkModeManager","dispatch","darkMode","toggleSetDarkMode","useIsExpertMode","state","userExpertMode","useExpertModeManager","expertMode","toggleSetExpertMode","useUserSlippageTolerance","userSlippageTolerance","setUserSlippageTolerance","useUserDeadline","userDeadline","setUserDeadline","useAddUserToken","useRemoveUserAddedToken","useUserAddedTokens","serializedTokensMap","tokens","_serializedTokensMap","Object","values","map","serializePair","pair","token0","token1","usePairAdder","serializedPair","useTokenWarningDismissal","dismissalState","dismissedTokenWarnings","defaultList","isDefault","_dismissalState$chain","dismissed","callback","tokenAddress","toV2LiquidityToken","tokenA","tokenB","getAddress","useTrackedTokenPairs","pinnedPairs","_PINNED_PAIRS$chainId","generatedPairs","keys","_BASES_TO_TRACK_LIQUI","base","filter","p","savedSerializedPairs","pairs","userPairs","forChain","pairId","combinedList","concat","keyed","reduce","memo","sorted","sortsBefore","key"],"sources":["/Users/synallage/Desktop/fomoswap-uni/interface-73580de922ce3ff642430d71aa24f5c053e6dd4d/src/state/user/hooks.tsx"],"sourcesContent":["import { ChainId, Pair, Token, Currency } from 'fomoswap-bera1'\nimport flatMap from 'lodash.flatmap'\nimport { useCallback, useMemo } from 'react'\nimport { shallowEqual, useDispatch, useSelector } from 'react-redux'\nimport { BASES_TO_TRACK_LIQUIDITY_FOR, PINNED_PAIRS } from '../../constants'\n\nimport { useActiveWeb3React } from '../../hooks'\nimport { useAllTokens } from '../../hooks/Tokens'\nimport { AppDispatch, AppState } from '../index'\nimport {\n  addSerializedPair,\n  addSerializedToken,\n  dismissTokenWarning,\n  removeSerializedToken,\n  SerializedPair,\n  SerializedToken,\n  updateUserDarkMode,\n  updateUserDeadline,\n  updateUserExpertMode,\n  updateUserSlippageTolerance\n} from './actions'\nimport { useDefaultTokenList } from '../lists/hooks'\nimport { isDefaultToken } from '../../utils'\n\nfunction serializeToken(token: Token): SerializedToken {\n  return {\n    chainId: token.chainId,\n    address: token.address,\n    decimals: token.decimals,\n    symbol: token.symbol,\n    name: token.name\n  }\n}\n\nfunction deserializeToken(serializedToken: SerializedToken): Token {\n  return new Token(\n    serializedToken.chainId,\n    serializedToken.address,\n    serializedToken.decimals,\n    serializedToken.symbol,\n    serializedToken.name\n  )\n}\n\nexport function useIsDarkMode(): boolean {\n  const { userDarkMode, matchesDarkMode } = useSelector<\n    AppState,\n    { userDarkMode: boolean | null; matchesDarkMode: boolean }\n  >(\n    ({ user: { matchesDarkMode, userDarkMode } }) => ({\n      userDarkMode,\n      matchesDarkMode\n    }),\n    shallowEqual\n  )\n\n  return userDarkMode === null ? matchesDarkMode : userDarkMode\n}\n\nexport function useDarkModeManager(): [boolean, () => void] {\n  const dispatch = useDispatch<AppDispatch>()\n  const darkMode = useIsDarkMode()\n\n  const toggleSetDarkMode = useCallback(() => {\n    dispatch(updateUserDarkMode({ userDarkMode: !darkMode }))\n  }, [darkMode, dispatch])\n\n  return [darkMode, toggleSetDarkMode]\n}\n\nexport function useIsExpertMode(): boolean {\n  return useSelector<AppState, AppState['user']['userExpertMode']>(state => state.user.userExpertMode)\n}\n\nexport function useExpertModeManager(): [boolean, () => void] {\n  const dispatch = useDispatch<AppDispatch>()\n  const expertMode = useIsExpertMode()\n\n  const toggleSetExpertMode = useCallback(() => {\n    dispatch(updateUserExpertMode({ userExpertMode: !expertMode }))\n  }, [expertMode, dispatch])\n\n  return [expertMode, toggleSetExpertMode]\n}\n\nexport function useUserSlippageTolerance(): [number, (slippage: number) => void] {\n  const dispatch = useDispatch<AppDispatch>()\n  const userSlippageTolerance = useSelector<AppState, AppState['user']['userSlippageTolerance']>(state => {\n    return state.user.userSlippageTolerance\n  })\n\n  const setUserSlippageTolerance = useCallback(\n    (userSlippageTolerance: number) => {\n      dispatch(updateUserSlippageTolerance({ userSlippageTolerance }))\n    },\n    [dispatch]\n  )\n\n  return [userSlippageTolerance, setUserSlippageTolerance]\n}\n\nexport function useUserDeadline(): [number, (slippage: number) => void] {\n  const dispatch = useDispatch<AppDispatch>()\n  const userDeadline = useSelector<AppState, AppState['user']['userDeadline']>(state => {\n    return state.user.userDeadline\n  })\n\n  const setUserDeadline = useCallback(\n    (userDeadline: number) => {\n      dispatch(updateUserDeadline({ userDeadline }))\n    },\n    [dispatch]\n  )\n\n  return [userDeadline, setUserDeadline]\n}\n\nexport function useAddUserToken(): (token: Token) => void {\n  const dispatch = useDispatch<AppDispatch>()\n  return useCallback(\n    (token: Token) => {\n      dispatch(addSerializedToken({ serializedToken: serializeToken(token) }))\n    },\n    [dispatch]\n  )\n}\n\nexport function useRemoveUserAddedToken(): (chainId: number, address: string) => void {\n  const dispatch = useDispatch<AppDispatch>()\n  return useCallback(\n    (chainId: number, address: string) => {\n      dispatch(removeSerializedToken({ chainId, address }))\n    },\n    [dispatch]\n  )\n}\n\nexport function useUserAddedTokens(): Token[] {\n  const { chainId } = useActiveWeb3React()\n  const serializedTokensMap = useSelector<AppState, AppState['user']['tokens']>(({ user: { tokens } }) => tokens)\n\n  return useMemo(() => {\n    if (!chainId) return []\n    return Object.values(serializedTokensMap[chainId as ChainId] ?? {}).map(deserializeToken)\n  }, [serializedTokensMap, chainId])\n}\n\nfunction serializePair(pair: Pair): SerializedPair {\n  return {\n    token0: serializeToken(pair.token0),\n    token1: serializeToken(pair.token1)\n  }\n}\n\nexport function usePairAdder(): (pair: Pair) => void {\n  const dispatch = useDispatch<AppDispatch>()\n\n  return useCallback(\n    (pair: Pair) => {\n      dispatch(addSerializedPair({ serializedPair: serializePair(pair) }))\n    },\n    [dispatch]\n  )\n}\n\n/**\n * Returns whether a token warning has been dismissed and a callback to dismiss it,\n * iff it has not already been dismissed and is a valid token.\n */\nexport function useTokenWarningDismissal(chainId?: number, token?: Currency): [boolean, null | (() => void)] {\n  const dismissalState = useSelector<AppState, AppState['user']['dismissedTokenWarnings']>(\n    state => state.user.dismissedTokenWarnings\n  )\n\n  const dispatch = useDispatch<AppDispatch>()\n\n  // get default list, mark as dismissed if on list\n  const defaultList = useDefaultTokenList()\n  const isDefault = isDefaultToken(defaultList, token)\n\n  return useMemo(() => {\n    if (!chainId || !token) return [false, null]\n\n    const dismissed: boolean =\n      token instanceof Token ? dismissalState?.[chainId]?.[token.address] === true || isDefault : true\n\n    const callback =\n      dismissed || !(token instanceof Token)\n        ? null\n        : () => dispatch(dismissTokenWarning({ chainId, tokenAddress: token.address }))\n\n    return [dismissed, callback]\n  }, [chainId, token, dismissalState, isDefault, dispatch])\n}\n\n/**\n * Given two tokens return the liquidity token that represents its liquidity shares\n * @param tokenA one of the two tokens\n * @param tokenB the other token\n */\nexport function toV2LiquidityToken([tokenA, tokenB]: [Token, Token]): Token {\n  return new Token(tokenA.chainId, Pair.getAddress(tokenA, tokenB), 18, 'UNI-V2', 'Uniswap V2')\n}\n\n/**\n * Returns all the pairs of tokens that are tracked by the user for the current chain ID.\n */\nexport function useTrackedTokenPairs(): [Token, Token][] {\n  const { chainId } = useActiveWeb3React()\n  const tokens = useAllTokens()\n\n  // pinned pairs\n  const pinnedPairs = useMemo(() => (chainId ? PINNED_PAIRS[chainId] ?? [] : []), [chainId])\n\n  // pairs for every token against every base\n  const generatedPairs: [Token, Token][] = useMemo(\n    () =>\n      chainId\n        ? flatMap(Object.keys(tokens), tokenAddress => {\n            const token = tokens[tokenAddress]\n            // for each token on the current chain,\n            return (\n              // loop though all bases on the current chain\n              (BASES_TO_TRACK_LIQUIDITY_FOR[chainId] ?? [])\n                // to construct pairs of the given token with each base\n                .map(base => {\n                  if (base.address === token.address) {\n                    return null\n                  } else {\n                    return [base, token]\n                  }\n                })\n                .filter((p): p is [Token, Token] => p !== null)\n            )\n          })\n        : [],\n    [tokens, chainId]\n  )\n\n  // pairs saved by users\n  const savedSerializedPairs = useSelector<AppState, AppState['user']['pairs']>(({ user: { pairs } }) => pairs)\n\n  const userPairs: [Token, Token][] = useMemo(() => {\n    if (!chainId || !savedSerializedPairs) return []\n    const forChain = savedSerializedPairs[chainId]\n    if (!forChain) return []\n\n    return Object.keys(forChain).map(pairId => {\n      return [deserializeToken(forChain[pairId].token0), deserializeToken(forChain[pairId].token1)]\n    })\n  }, [savedSerializedPairs, chainId])\n\n  const combinedList = useMemo(() => userPairs.concat(generatedPairs).concat(pinnedPairs), [\n    generatedPairs,\n    pinnedPairs,\n    userPairs\n  ])\n\n  return useMemo(() => {\n    // dedupes pairs of tokens in the combined list\n    const keyed = combinedList.reduce<{ [key: string]: [Token, Token] }>((memo, [tokenA, tokenB]) => {\n      const sorted = tokenA.sortsBefore(tokenB)\n      const key = sorted ? `${tokenA.address}:${tokenB.address}` : `${tokenB.address}:${tokenA.address}`\n      if (memo[key]) return memo\n      memo[key] = sorted ? [tokenA, tokenB] : [tokenB, tokenA]\n      return memo\n    }, {})\n\n    return Object.keys(keyed).map(key => keyed[key])\n  }, [combinedList])\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}