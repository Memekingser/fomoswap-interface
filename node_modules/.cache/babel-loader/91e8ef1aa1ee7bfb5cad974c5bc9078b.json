{"ast":null,"code":"import { Trade } from 'fomoswap-storytestnet';\nimport flatMap from 'lodash.flatmap';\nimport { useMemo } from 'react';\nimport { BASES_TO_CHECK_TRADES_AGAINST, CUSTOM_BASES } from '../constants';\nimport { PairState, usePairs } from '../data/Reserves';\nimport { wrappedCurrency } from '../utils/wrappedCurrency';\nimport { useActiveWeb3React } from './index';\nfunction useAllCommonPairs(currencyA, currencyB) {\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const bases = chainId ? BASES_TO_CHECK_TRADES_AGAINST[chainId] : [];\n  const [tokenA, tokenB] = chainId ? [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)] : [undefined, undefined];\n  const allPairCombinations = useMemo(() => [\n  // the direct pair\n  [tokenA, tokenB],\n  // token A against all bases\n  ...bases.map(base => [tokenA, base]),\n  // token B against all bases\n  ...bases.map(base => [tokenB, base]),\n  // each base against all bases\n  ...flatMap(bases, base => bases.map(otherBase => [base, otherBase]))].filter(tokens => Boolean(tokens[0] && tokens[1])).filter(([tokenA, tokenB]) => {\n    if (!chainId) return true;\n    const customBases = CUSTOM_BASES[chainId];\n    if (!customBases) return true;\n    const customBasesA = customBases[tokenA.address];\n    const customBasesB = customBases[tokenB.address];\n    if (!customBasesA && !customBasesB) return true;\n    if (customBasesA && customBasesA.findIndex(base => tokenB.equals(base)) === -1) return false;\n    if (customBasesB && customBasesB.findIndex(base => tokenA.equals(base)) === -1) return false;\n    return true;\n  }), [tokenA, tokenB, bases, chainId]);\n  const allPairs = usePairs(allPairCombinations);\n\n  // only pass along valid pairs, non-duplicated pairs\n  return useMemo(() => Object.values(allPairs\n  // filter out invalid pairs\n  .filter(result => Boolean(result[0] === PairState.EXISTS && result[1]))\n  // filter out duplicated pairs\n  .reduce((memo, [, curr]) => {\n    var _memo$curr$liquidityT;\n    memo[curr.liquidityToken.address] = (_memo$curr$liquidityT = memo[curr.liquidityToken.address]) !== null && _memo$curr$liquidityT !== void 0 ? _memo$curr$liquidityT : curr;\n    return memo;\n  }, {})), [allPairs]);\n}\n\n/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */\nexport function useTradeExactIn(currencyAmountIn, currencyOut) {\n  const allowedPairs = useAllCommonPairs(currencyAmountIn === null || currencyAmountIn === void 0 ? void 0 : currencyAmountIn.currency, currencyOut);\n  return useMemo(() => {\n    if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\n      var _Trade$bestTradeExact;\n      return (_Trade$bestTradeExact = Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, {\n        maxHops: 3,\n        maxNumResults: 1\n      })[0]) !== null && _Trade$bestTradeExact !== void 0 ? _Trade$bestTradeExact : null;\n    }\n    return null;\n  }, [allowedPairs, currencyAmountIn, currencyOut]);\n}\n\n/**\n * Returns the best trade for the token in to the exact amount of token out\n */\nexport function useTradeExactOut(currencyIn, currencyAmountOut) {\n  const allowedPairs = useAllCommonPairs(currencyIn, currencyAmountOut === null || currencyAmountOut === void 0 ? void 0 : currencyAmountOut.currency);\n  return useMemo(() => {\n    if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\n      var _Trade$bestTradeExact2;\n      return (_Trade$bestTradeExact2 = Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, {\n        maxHops: 3,\n        maxNumResults: 1\n      })[0]) !== null && _Trade$bestTradeExact2 !== void 0 ? _Trade$bestTradeExact2 : null;\n    }\n    return null;\n  }, [allowedPairs, currencyIn, currencyAmountOut]);\n}","map":{"version":3,"names":["Trade","flatMap","useMemo","BASES_TO_CHECK_TRADES_AGAINST","CUSTOM_BASES","PairState","usePairs","wrappedCurrency","useActiveWeb3React","useAllCommonPairs","currencyA","currencyB","chainId","bases","tokenA","tokenB","undefined","allPairCombinations","map","base","otherBase","filter","tokens","Boolean","customBases","customBasesA","address","customBasesB","findIndex","equals","allPairs","Object","values","result","EXISTS","reduce","memo","curr","_memo$curr$liquidityT","liquidityToken","useTradeExactIn","currencyAmountIn","currencyOut","allowedPairs","currency","length","_Trade$bestTradeExact","bestTradeExactIn","maxHops","maxNumResults","useTradeExactOut","currencyIn","currencyAmountOut","_Trade$bestTradeExact2","bestTradeExactOut"],"sources":["/Users/synallage/Desktop/fomoswap-uni/interface-73580de922ce3ff642430d71aa24f5c053e6dd4d/src/hooks/Trades.ts"],"sourcesContent":["import { Currency, CurrencyAmount, Pair, Token, Trade } from 'fomoswap-storytestnet'\nimport flatMap from 'lodash.flatmap'\nimport { useMemo } from 'react'\n\nimport { BASES_TO_CHECK_TRADES_AGAINST, CUSTOM_BASES } from '../constants'\nimport { PairState, usePairs } from '../data/Reserves'\nimport { wrappedCurrency } from '../utils/wrappedCurrency'\n\nimport { useActiveWeb3React } from './index'\n\nfunction useAllCommonPairs(currencyA?: Currency, currencyB?: Currency): Pair[] {\n  const { chainId } = useActiveWeb3React()\n\n  const bases: Token[] = chainId ? BASES_TO_CHECK_TRADES_AGAINST[chainId] : []\n\n  const [tokenA, tokenB] = chainId\n    ? [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)]\n    : [undefined, undefined]\n\n  const allPairCombinations: [Token, Token][] = useMemo(\n    () =>\n      [\n        // the direct pair\n        [tokenA, tokenB],\n        // token A against all bases\n        ...bases.map((base): [Token | undefined, Token | undefined] => [tokenA, base]),\n        // token B against all bases\n        ...bases.map((base): [Token | undefined, Token | undefined] => [tokenB, base]),\n        // each base against all bases\n        ...flatMap(bases, (base): [Token, Token][] => bases.map(otherBase => [base, otherBase]))\n      ]\n        .filter((tokens): tokens is [Token, Token] => Boolean(tokens[0] && tokens[1]))\n        .filter(([tokenA, tokenB]) => {\n          if (!chainId) return true\n          const customBases = CUSTOM_BASES[chainId]\n          if (!customBases) return true\n\n          const customBasesA: Token[] | undefined = customBases[tokenA.address]\n          const customBasesB: Token[] | undefined = customBases[tokenB.address]\n\n          if (!customBasesA && !customBasesB) return true\n\n          if (customBasesA && customBasesA.findIndex(base => tokenB.equals(base)) === -1) return false\n          if (customBasesB && customBasesB.findIndex(base => tokenA.equals(base)) === -1) return false\n\n          return true\n        }),\n    [tokenA, tokenB, bases, chainId]\n  )\n\n  const allPairs = usePairs(allPairCombinations)\n\n  // only pass along valid pairs, non-duplicated pairs\n  return useMemo(\n    () =>\n      Object.values(\n        allPairs\n          // filter out invalid pairs\n          .filter((result): result is [PairState.EXISTS, Pair] => Boolean(result[0] === PairState.EXISTS && result[1]))\n          // filter out duplicated pairs\n          .reduce<{ [pairAddress: string]: Pair }>((memo, [, curr]) => {\n            memo[curr.liquidityToken.address] = memo[curr.liquidityToken.address] ?? curr\n            return memo\n          }, {})\n      ),\n    [allPairs]\n  )\n}\n\n/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */\nexport function useTradeExactIn(currencyAmountIn?: CurrencyAmount, currencyOut?: Currency): Trade | null {\n  const allowedPairs = useAllCommonPairs(currencyAmountIn?.currency, currencyOut)\n\n  return useMemo(() => {\n    if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\n      return (\n        Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, { maxHops: 3, maxNumResults: 1 })[0] ?? null\n      )\n    }\n    return null\n  }, [allowedPairs, currencyAmountIn, currencyOut])\n}\n\n/**\n * Returns the best trade for the token in to the exact amount of token out\n */\nexport function useTradeExactOut(currencyIn?: Currency, currencyAmountOut?: CurrencyAmount): Trade | null {\n  const allowedPairs = useAllCommonPairs(currencyIn, currencyAmountOut?.currency)\n\n  return useMemo(() => {\n    if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\n      return (\n        Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, { maxHops: 3, maxNumResults: 1 })[0] ??\n        null\n      )\n    }\n    return null\n  }, [allowedPairs, currencyIn, currencyAmountOut])\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}