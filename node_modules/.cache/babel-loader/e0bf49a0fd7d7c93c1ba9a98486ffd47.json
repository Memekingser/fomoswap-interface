{"ast":null,"code":"import { CurrencyAmount, ETHER, JSBI, Token, TokenAmount } from 'fomoswap-storytestnet';\nimport { useMemo } from 'react';\nimport ERC20_INTERFACE from '../../constants/abis/erc20';\nimport { useAllTokens } from '../../hooks/Tokens';\nimport { useActiveWeb3React } from '../../hooks';\nimport { useMulticallContract } from '../../hooks/useContract';\nimport { isAddress } from '../../utils';\nimport { useSingleContractMultipleData, useMultipleContractSingleData } from '../multicall/hooks';\n\n/**\n * Returns a map of the given addresses to their eventually consistent ETH balances.\n */\nexport function useETHBalances(uncheckedAddresses) {\n  const multicallContract = useMulticallContract();\n  const addresses = useMemo(() => uncheckedAddresses ? uncheckedAddresses.map(isAddress).filter(a => a !== false).sort() : [], [uncheckedAddresses]);\n  const results = useSingleContractMultipleData(multicallContract, 'getEthBalance', addresses.map(address => [address]));\n  return useMemo(() => addresses.reduce((memo, address, i) => {\n    var _results$i, _results$i$result;\n    const value = results === null || results === void 0 ? void 0 : (_results$i = results[i]) === null || _results$i === void 0 ? void 0 : (_results$i$result = _results$i.result) === null || _results$i$result === void 0 ? void 0 : _results$i$result[0];\n    if (value) memo[address] = CurrencyAmount.ether(JSBI.BigInt(value.toString()));\n    return memo;\n  }, {}), [addresses, results]);\n}\n\n/**\n * Returns a map of token addresses to their eventually consistent token balances for a single account.\n */\nexport function useTokenBalancesWithLoadingIndicator(address, tokens) {\n  const validatedTokens = useMemo(() => {\n    var _tokens$filter;\n    return (_tokens$filter = tokens === null || tokens === void 0 ? void 0 : tokens.filter(t => isAddress(t === null || t === void 0 ? void 0 : t.address) !== false)) !== null && _tokens$filter !== void 0 ? _tokens$filter : [];\n  }, [tokens]);\n  const validatedTokenAddresses = useMemo(() => validatedTokens.map(vt => vt.address), [validatedTokens]);\n  const balances = useMultipleContractSingleData(validatedTokenAddresses, ERC20_INTERFACE, 'balanceOf', [address]);\n  const anyLoading = useMemo(() => balances.some(callState => callState.loading), [balances]);\n  return [useMemo(() => address && validatedTokens.length > 0 ? validatedTokens.reduce((memo, token, i) => {\n    var _balances$i, _balances$i$result;\n    const value = balances === null || balances === void 0 ? void 0 : (_balances$i = balances[i]) === null || _balances$i === void 0 ? void 0 : (_balances$i$result = _balances$i.result) === null || _balances$i$result === void 0 ? void 0 : _balances$i$result[0];\n    const amount = value ? JSBI.BigInt(value.toString()) : undefined;\n    if (amount) {\n      memo[token.address] = new TokenAmount(token, amount);\n    }\n    return memo;\n  }, {}) : {}, [address, validatedTokens, balances]), anyLoading];\n}\nexport function useTokenBalances(address, tokens) {\n  return useTokenBalancesWithLoadingIndicator(address, tokens)[0];\n}\n\n// get the balance for a single token/account combo\nexport function useTokenBalance(account, token) {\n  const tokenBalances = useTokenBalances(account, [token]);\n  if (!token) return;\n  return tokenBalances[token.address];\n}\nexport function useCurrencyBalances(account, currencies) {\n  const tokens = useMemo(() => {\n    var _currencies$filter;\n    return (_currencies$filter = currencies === null || currencies === void 0 ? void 0 : currencies.filter(currency => currency instanceof Token)) !== null && _currencies$filter !== void 0 ? _currencies$filter : [];\n  }, [currencies]);\n  const tokenBalances = useTokenBalances(account, tokens);\n  const containsETH = useMemo(() => {\n    var _currencies$some;\n    return (_currencies$some = currencies === null || currencies === void 0 ? void 0 : currencies.some(currency => currency === ETHER)) !== null && _currencies$some !== void 0 ? _currencies$some : false;\n  }, [currencies]);\n  const ethBalance = useETHBalances(containsETH ? [account] : []);\n  return useMemo(() => {\n    var _currencies$map;\n    return (_currencies$map = currencies === null || currencies === void 0 ? void 0 : currencies.map(currency => {\n      if (!account || !currency) return;\n      if (currency instanceof Token) return tokenBalances[currency.address];\n      if (currency === ETHER) return ethBalance[account];\n      return;\n    })) !== null && _currencies$map !== void 0 ? _currencies$map : [];\n  }, [account, currencies, ethBalance, tokenBalances]);\n}\nexport function useCurrencyBalance(account, currency) {\n  return useCurrencyBalances(account, [currency])[0];\n}\n\n// mimics useAllBalances\nexport function useAllTokenBalances() {\n  const {\n    account\n  } = useActiveWeb3React();\n  const allTokens = useAllTokens();\n  const allTokensArray = useMemo(() => Object.values(allTokens !== null && allTokens !== void 0 ? allTokens : {}), [allTokens]);\n  const balances = useTokenBalances(account !== null && account !== void 0 ? account : undefined, allTokensArray);\n  return balances !== null && balances !== void 0 ? balances : {};\n}","map":{"version":3,"names":["CurrencyAmount","ETHER","JSBI","Token","TokenAmount","useMemo","ERC20_INTERFACE","useAllTokens","useActiveWeb3React","useMulticallContract","isAddress","useSingleContractMultipleData","useMultipleContractSingleData","useETHBalances","uncheckedAddresses","multicallContract","addresses","map","filter","a","sort","results","address","reduce","memo","i","_results$i","_results$i$result","value","result","ether","BigInt","toString","useTokenBalancesWithLoadingIndicator","tokens","validatedTokens","_tokens$filter","t","validatedTokenAddresses","vt","balances","anyLoading","some","callState","loading","length","token","_balances$i","_balances$i$result","amount","undefined","useTokenBalances","useTokenBalance","account","tokenBalances","useCurrencyBalances","currencies","_currencies$filter","currency","containsETH","_currencies$some","ethBalance","_currencies$map","useCurrencyBalance","useAllTokenBalances","allTokens","allTokensArray","Object","values"],"sources":["/Users/synallage/Desktop/fomoswap-uni/interface-73580de922ce3ff642430d71aa24f5c053e6dd4d/src/state/wallet/hooks.ts"],"sourcesContent":["import { Currency, CurrencyAmount, ETHER, JSBI, Token, TokenAmount } from 'fomoswap-storytestnet'\nimport { useMemo } from 'react'\nimport ERC20_INTERFACE from '../../constants/abis/erc20'\nimport { useAllTokens } from '../../hooks/Tokens'\nimport { useActiveWeb3React } from '../../hooks'\nimport { useMulticallContract } from '../../hooks/useContract'\nimport { isAddress } from '../../utils'\nimport { useSingleContractMultipleData, useMultipleContractSingleData } from '../multicall/hooks'\n\n/**\n * Returns a map of the given addresses to their eventually consistent ETH balances.\n */\nexport function useETHBalances(\n  uncheckedAddresses?: (string | undefined)[]\n): { [address: string]: CurrencyAmount | undefined } {\n  const multicallContract = useMulticallContract()\n\n  const addresses: string[] = useMemo(\n    () =>\n      uncheckedAddresses\n        ? uncheckedAddresses\n            .map(isAddress)\n            .filter((a): a is string => a !== false)\n            .sort()\n        : [],\n    [uncheckedAddresses]\n  )\n\n  const results = useSingleContractMultipleData(\n    multicallContract,\n    'getEthBalance',\n    addresses.map(address => [address])\n  )\n\n  return useMemo(\n    () =>\n      addresses.reduce<{ [address: string]: CurrencyAmount }>((memo, address, i) => {\n        const value = results?.[i]?.result?.[0]\n        if (value) memo[address] = CurrencyAmount.ether(JSBI.BigInt(value.toString()))\n        return memo\n      }, {}),\n    [addresses, results]\n  )\n}\n\n/**\n * Returns a map of token addresses to their eventually consistent token balances for a single account.\n */\nexport function useTokenBalancesWithLoadingIndicator(\n  address?: string,\n  tokens?: (Token | undefined)[]\n): [{ [tokenAddress: string]: TokenAmount | undefined }, boolean] {\n  const validatedTokens: Token[] = useMemo(\n    () => tokens?.filter((t?: Token): t is Token => isAddress(t?.address) !== false) ?? [],\n    [tokens]\n  )\n\n  const validatedTokenAddresses = useMemo(() => validatedTokens.map(vt => vt.address), [validatedTokens])\n\n  const balances = useMultipleContractSingleData(validatedTokenAddresses, ERC20_INTERFACE, 'balanceOf', [address])\n\n  const anyLoading: boolean = useMemo(() => balances.some(callState => callState.loading), [balances])\n\n  return [\n    useMemo(\n      () =>\n        address && validatedTokens.length > 0\n          ? validatedTokens.reduce<{ [tokenAddress: string]: TokenAmount | undefined }>((memo, token, i) => {\n              const value = balances?.[i]?.result?.[0]\n              const amount = value ? JSBI.BigInt(value.toString()) : undefined\n              if (amount) {\n                memo[token.address] = new TokenAmount(token, amount)\n              }\n              return memo\n            }, {})\n          : {},\n      [address, validatedTokens, balances]\n    ),\n    anyLoading\n  ]\n}\n\nexport function useTokenBalances(\n  address?: string,\n  tokens?: (Token | undefined)[]\n): { [tokenAddress: string]: TokenAmount | undefined } {\n  return useTokenBalancesWithLoadingIndicator(address, tokens)[0]\n}\n\n// get the balance for a single token/account combo\nexport function useTokenBalance(account?: string, token?: Token): TokenAmount | undefined {\n  const tokenBalances = useTokenBalances(account, [token])\n  if (!token) return\n  return tokenBalances[token.address]\n}\n\nexport function useCurrencyBalances(\n  account?: string,\n  currencies?: (Currency | undefined)[]\n): (CurrencyAmount | undefined)[] {\n  const tokens = useMemo(() => currencies?.filter((currency): currency is Token => currency instanceof Token) ?? [], [\n    currencies\n  ])\n\n  const tokenBalances = useTokenBalances(account, tokens)\n  const containsETH: boolean = useMemo(() => currencies?.some(currency => currency === ETHER) ?? false, [currencies])\n  const ethBalance = useETHBalances(containsETH ? [account] : [])\n\n  return useMemo(\n    () =>\n      currencies?.map(currency => {\n        if (!account || !currency) return\n        if (currency instanceof Token) return tokenBalances[currency.address]\n        if (currency === ETHER) return ethBalance[account]\n        return\n      }) ?? [],\n    [account, currencies, ethBalance, tokenBalances]\n  )\n}\n\nexport function useCurrencyBalance(account?: string, currency?: Currency): CurrencyAmount | undefined {\n  return useCurrencyBalances(account, [currency])[0]\n}\n\n// mimics useAllBalances\nexport function useAllTokenBalances(): { [tokenAddress: string]: TokenAmount | undefined } {\n  const { account } = useActiveWeb3React()\n  const allTokens = useAllTokens()\n  const allTokensArray = useMemo(() => Object.values(allTokens ?? {}), [allTokens])\n  const balances = useTokenBalances(account ?? undefined, allTokensArray)\n  return balances ?? {}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}