{"ast":null,"code":"import { AddressZero } from '@ethersproject/constants';\nimport { currencyEquals, ETHER, JSBI, Pair, Percent, Route, Token, TokenAmount, Trade, TradeType, WETH } from 'fomoswap-story';\nimport { useMemo } from 'react';\nimport { useActiveWeb3React } from '../hooks';\nimport { useAllTokens } from '../hooks/Tokens';\nimport { useV1FactoryContract } from '../hooks/useContract';\nimport { Version } from '../hooks/useToggledVersion';\nimport { NEVER_RELOAD, useSingleCallResult, useSingleContractMultipleData } from '../state/multicall/hooks';\nimport { useETHBalances, useTokenBalance, useTokenBalances } from '../state/wallet/hooks';\nexport function useV1ExchangeAddress(tokenAddress) {\n  var _useSingleCallResult, _useSingleCallResult$;\n  const contract = useV1FactoryContract();\n  const inputs = useMemo(() => [tokenAddress], [tokenAddress]);\n  return (_useSingleCallResult = useSingleCallResult(contract, 'getExchange', inputs)) === null || _useSingleCallResult === void 0 ? void 0 : (_useSingleCallResult$ = _useSingleCallResult.result) === null || _useSingleCallResult$ === void 0 ? void 0 : _useSingleCallResult$[0];\n}\nexport class MockV1Pair extends Pair {\n  constructor(etherAmount, tokenAmount) {\n    super(tokenAmount, new TokenAmount(WETH[tokenAmount.token.chainId], etherAmount));\n  }\n}\nfunction useMockV1Pair(inputCurrency) {\n  const token = inputCurrency instanceof Token ? inputCurrency : undefined;\n  const isWETH = Boolean(token && token.equals(WETH[token.chainId]));\n  const v1PairAddress = useV1ExchangeAddress(isWETH ? undefined : token === null || token === void 0 ? void 0 : token.address);\n  const tokenBalance = useTokenBalance(v1PairAddress, token);\n  const ETHBalance = useETHBalances([v1PairAddress])[v1PairAddress !== null && v1PairAddress !== void 0 ? v1PairAddress : ''];\n  return useMemo(() => token && tokenBalance && ETHBalance && inputCurrency ? new MockV1Pair(ETHBalance.raw, tokenBalance) : undefined, [ETHBalance, inputCurrency, token, tokenBalance]);\n}\n\n// returns all v1 exchange addresses in the user's token list\nexport function useAllTokenV1Exchanges() {\n  const allTokens = useAllTokens();\n  const factory = useV1FactoryContract();\n  const args = useMemo(() => Object.keys(allTokens).map(tokenAddress => [tokenAddress]), [allTokens]);\n  const data = useSingleContractMultipleData(factory, 'getExchange', args, NEVER_RELOAD);\n  return useMemo(() => {\n    var _data$reduce;\n    return (_data$reduce = data === null || data === void 0 ? void 0 : data.reduce((memo, {\n      result\n    }, ix) => {\n      if ((result === null || result === void 0 ? void 0 : result[0]) && result[0] !== AddressZero) {\n        memo[result[0]] = allTokens[args[ix][0]];\n      }\n      return memo;\n    }, {})) !== null && _data$reduce !== void 0 ? _data$reduce : {};\n  }, [allTokens, args, data]);\n}\n\n// returns whether any of the tokens in the user's token list have liquidity on v1\nexport function useUserHasLiquidityInAllTokens() {\n  const {\n    account,\n    chainId\n  } = useActiveWeb3React();\n  const exchanges = useAllTokenV1Exchanges();\n  const v1ExchangeLiquidityTokens = useMemo(() => chainId ? Object.keys(exchanges).map(address => new Token(chainId, address, 18, 'UNI-V1', 'Uniswap V1')) : [], [chainId, exchanges]);\n  const balances = useTokenBalances(account !== null && account !== void 0 ? account : undefined, v1ExchangeLiquidityTokens);\n  return useMemo(() => Object.keys(balances).some(tokenAddress => {\n    var _balances$tokenAddres;\n    const b = (_balances$tokenAddres = balances[tokenAddress]) === null || _balances$tokenAddres === void 0 ? void 0 : _balances$tokenAddres.raw;\n    return b && JSBI.greaterThan(b, JSBI.BigInt(0));\n  }), [balances]);\n}\n\n/**\n * Returns the trade to execute on V1 to go between input and output token\n */\nexport function useV1Trade(isExactIn, inputCurrency, outputCurrency, exactAmount) {\n  // get the mock v1 pairs\n  const inputPair = useMockV1Pair(inputCurrency);\n  const outputPair = useMockV1Pair(outputCurrency);\n  const inputIsETH = inputCurrency === ETHER;\n  const outputIsETH = outputCurrency === ETHER;\n\n  // construct a direct or through ETH v1 route\n  let pairs = [];\n  if (inputIsETH && outputPair) {\n    pairs = [outputPair];\n  } else if (outputIsETH && inputPair) {\n    pairs = [inputPair];\n  }\n  // if neither are ETH, it's token-to-token (if they both exist)\n  else if (inputPair && outputPair) {\n    pairs = [inputPair, outputPair];\n  }\n  const route = inputCurrency && pairs && pairs.length > 0 && new Route(pairs, inputCurrency, outputCurrency);\n  let v1Trade;\n  try {\n    v1Trade = route && exactAmount ? new Trade(route, exactAmount, isExactIn ? TradeType.EXACT_INPUT : TradeType.EXACT_OUTPUT) : undefined;\n  } catch (error) {\n    console.debug('Failed to create V1 trade', error);\n  }\n  return v1Trade;\n}\nexport function getTradeVersion(trade) {\n  var _trade$route, _trade$route$pairs;\n  const isV1 = trade === null || trade === void 0 ? void 0 : (_trade$route = trade.route) === null || _trade$route === void 0 ? void 0 : (_trade$route$pairs = _trade$route.pairs) === null || _trade$route$pairs === void 0 ? void 0 : _trade$route$pairs.some(pair => pair instanceof MockV1Pair);\n  if (isV1) return Version.v1;\n  if (isV1 === false) return Version.v2;\n  return undefined;\n}\n\n// returns the v1 exchange against which a trade should be executed\nexport function useV1TradeExchangeAddress(trade) {\n  const tokenAddress = useMemo(() => {\n    if (!trade) return undefined;\n    const isV1 = getTradeVersion(trade) === Version.v1;\n    if (!isV1) return undefined;\n    return trade.inputAmount instanceof TokenAmount ? trade.inputAmount.token.address : trade.outputAmount instanceof TokenAmount ? trade.outputAmount.token.address : undefined;\n  }, [trade]);\n  return useV1ExchangeAddress(tokenAddress);\n}\nconst ZERO_PERCENT = new Percent('0');\nconst ONE_HUNDRED_PERCENT = new Percent('1');\n\n// returns whether tradeB is better than tradeA by at least a threshold percentage amount\nexport function isTradeBetter(tradeA, tradeB, minimumDelta = ZERO_PERCENT) {\n  if (!tradeA || !tradeB) return undefined;\n  if (tradeA.tradeType !== tradeB.tradeType || !currencyEquals(tradeA.inputAmount.currency, tradeB.inputAmount.currency) || !currencyEquals(tradeB.outputAmount.currency, tradeB.outputAmount.currency)) {\n    throw new Error('Trades are not comparable');\n  }\n  if (minimumDelta.equalTo(ZERO_PERCENT)) {\n    return tradeA.executionPrice.lessThan(tradeB.executionPrice);\n  } else {\n    return tradeA.executionPrice.raw.multiply(minimumDelta.add(ONE_HUNDRED_PERCENT)).lessThan(tradeB.executionPrice);\n  }\n}","map":{"version":3,"names":["AddressZero","currencyEquals","ETHER","JSBI","Pair","Percent","Route","Token","TokenAmount","Trade","TradeType","WETH","useMemo","useActiveWeb3React","useAllTokens","useV1FactoryContract","Version","NEVER_RELOAD","useSingleCallResult","useSingleContractMultipleData","useETHBalances","useTokenBalance","useTokenBalances","useV1ExchangeAddress","tokenAddress","_useSingleCallResult","_useSingleCallResult$","contract","inputs","result","MockV1Pair","constructor","etherAmount","tokenAmount","token","chainId","useMockV1Pair","inputCurrency","undefined","isWETH","Boolean","equals","v1PairAddress","address","tokenBalance","ETHBalance","raw","useAllTokenV1Exchanges","allTokens","factory","args","Object","keys","map","data","_data$reduce","reduce","memo","ix","useUserHasLiquidityInAllTokens","account","exchanges","v1ExchangeLiquidityTokens","balances","some","_balances$tokenAddres","b","greaterThan","BigInt","useV1Trade","isExactIn","outputCurrency","exactAmount","inputPair","outputPair","inputIsETH","outputIsETH","pairs","route","length","v1Trade","EXACT_INPUT","EXACT_OUTPUT","error","console","debug","getTradeVersion","trade","_trade$route","_trade$route$pairs","isV1","pair","v1","v2","useV1TradeExchangeAddress","inputAmount","outputAmount","ZERO_PERCENT","ONE_HUNDRED_PERCENT","isTradeBetter","tradeA","tradeB","minimumDelta","tradeType","currency","Error","equalTo","executionPrice","lessThan","multiply","add"],"sources":["/Users/synallage/Desktop/fomoswap-uni/interface-73580de922ce3ff642430d71aa24f5c053e6dd4d/src/data/V1.ts"],"sourcesContent":["import { AddressZero } from '@ethersproject/constants'\nimport {\n  BigintIsh,\n  Currency,\n  CurrencyAmount,\n  currencyEquals,\n  ETHER,\n  JSBI,\n  Pair,\n  Percent,\n  Route,\n  Token,\n  TokenAmount,\n  Trade,\n  TradeType,\n  WETH\n} from 'fomoswap-story'\nimport { useMemo } from 'react'\nimport { useActiveWeb3React } from '../hooks'\nimport { useAllTokens } from '../hooks/Tokens'\nimport { useV1FactoryContract } from '../hooks/useContract'\nimport { Version } from '../hooks/useToggledVersion'\nimport { NEVER_RELOAD, useSingleCallResult, useSingleContractMultipleData } from '../state/multicall/hooks'\nimport { useETHBalances, useTokenBalance, useTokenBalances } from '../state/wallet/hooks'\n\nexport function useV1ExchangeAddress(tokenAddress?: string): string | undefined {\n  const contract = useV1FactoryContract()\n\n  const inputs = useMemo(() => [tokenAddress], [tokenAddress])\n  return useSingleCallResult(contract, 'getExchange', inputs)?.result?.[0]\n}\n\nexport class MockV1Pair extends Pair {\n  constructor(etherAmount: BigintIsh, tokenAmount: TokenAmount) {\n    super(tokenAmount, new TokenAmount(WETH[tokenAmount.token.chainId], etherAmount))\n  }\n}\n\nfunction useMockV1Pair(inputCurrency?: Currency): MockV1Pair | undefined {\n  const token = inputCurrency instanceof Token ? inputCurrency : undefined\n\n  const isWETH = Boolean(token && token.equals(WETH[token.chainId]))\n  const v1PairAddress = useV1ExchangeAddress(isWETH ? undefined : token?.address)\n  const tokenBalance = useTokenBalance(v1PairAddress, token)\n  const ETHBalance = useETHBalances([v1PairAddress])[v1PairAddress ?? '']\n\n  return useMemo(\n    () =>\n      token && tokenBalance && ETHBalance && inputCurrency ? new MockV1Pair(ETHBalance.raw, tokenBalance) : undefined,\n    [ETHBalance, inputCurrency, token, tokenBalance]\n  )\n}\n\n// returns all v1 exchange addresses in the user's token list\nexport function useAllTokenV1Exchanges(): { [exchangeAddress: string]: Token } {\n  const allTokens = useAllTokens()\n  const factory = useV1FactoryContract()\n  const args = useMemo(() => Object.keys(allTokens).map(tokenAddress => [tokenAddress]), [allTokens])\n\n  const data = useSingleContractMultipleData(factory, 'getExchange', args, NEVER_RELOAD)\n\n  return useMemo(\n    () =>\n      data?.reduce<{ [exchangeAddress: string]: Token }>((memo, { result }, ix) => {\n        if (result?.[0] && result[0] !== AddressZero) {\n          memo[result[0]] = allTokens[args[ix][0]]\n        }\n        return memo\n      }, {}) ?? {},\n    [allTokens, args, data]\n  )\n}\n\n// returns whether any of the tokens in the user's token list have liquidity on v1\nexport function useUserHasLiquidityInAllTokens(): boolean | undefined {\n  const { account, chainId } = useActiveWeb3React()\n\n  const exchanges = useAllTokenV1Exchanges()\n\n  const v1ExchangeLiquidityTokens = useMemo(\n    () =>\n      chainId ? Object.keys(exchanges).map(address => new Token(chainId, address, 18, 'UNI-V1', 'Uniswap V1')) : [],\n    [chainId, exchanges]\n  )\n\n  const balances = useTokenBalances(account ?? undefined, v1ExchangeLiquidityTokens)\n\n  return useMemo(\n    () =>\n      Object.keys(balances).some(tokenAddress => {\n        const b = balances[tokenAddress]?.raw\n        return b && JSBI.greaterThan(b, JSBI.BigInt(0))\n      }),\n    [balances]\n  )\n}\n\n/**\n * Returns the trade to execute on V1 to go between input and output token\n */\nexport function useV1Trade(\n  isExactIn?: boolean,\n  inputCurrency?: Currency,\n  outputCurrency?: Currency,\n  exactAmount?: CurrencyAmount\n): Trade | undefined {\n  // get the mock v1 pairs\n  const inputPair = useMockV1Pair(inputCurrency)\n  const outputPair = useMockV1Pair(outputCurrency)\n\n  const inputIsETH = inputCurrency === ETHER\n  const outputIsETH = outputCurrency === ETHER\n\n  // construct a direct or through ETH v1 route\n  let pairs: Pair[] = []\n  if (inputIsETH && outputPair) {\n    pairs = [outputPair]\n  } else if (outputIsETH && inputPair) {\n    pairs = [inputPair]\n  }\n  // if neither are ETH, it's token-to-token (if they both exist)\n  else if (inputPair && outputPair) {\n    pairs = [inputPair, outputPair]\n  }\n\n  const route = inputCurrency && pairs && pairs.length > 0 && new Route(pairs, inputCurrency, outputCurrency)\n  let v1Trade: Trade | undefined\n  try {\n    v1Trade =\n      route && exactAmount\n        ? new Trade(route, exactAmount, isExactIn ? TradeType.EXACT_INPUT : TradeType.EXACT_OUTPUT)\n        : undefined\n  } catch (error) {\n    console.debug('Failed to create V1 trade', error)\n  }\n  return v1Trade\n}\n\nexport function getTradeVersion(trade?: Trade): Version | undefined {\n  const isV1 = trade?.route?.pairs?.some(pair => pair instanceof MockV1Pair)\n  if (isV1) return Version.v1\n  if (isV1 === false) return Version.v2\n  return undefined\n}\n\n// returns the v1 exchange against which a trade should be executed\nexport function useV1TradeExchangeAddress(trade: Trade | undefined): string | undefined {\n  const tokenAddress: string | undefined = useMemo(() => {\n    if (!trade) return undefined\n    const isV1 = getTradeVersion(trade) === Version.v1\n    if (!isV1) return undefined\n    return trade.inputAmount instanceof TokenAmount\n      ? trade.inputAmount.token.address\n      : trade.outputAmount instanceof TokenAmount\n      ? trade.outputAmount.token.address\n      : undefined\n  }, [trade])\n  return useV1ExchangeAddress(tokenAddress)\n}\n\nconst ZERO_PERCENT = new Percent('0')\nconst ONE_HUNDRED_PERCENT = new Percent('1')\n\n// returns whether tradeB is better than tradeA by at least a threshold percentage amount\nexport function isTradeBetter(\n  tradeA: Trade | undefined,\n  tradeB: Trade | undefined,\n  minimumDelta: Percent = ZERO_PERCENT\n): boolean | undefined {\n  if (!tradeA || !tradeB) return undefined\n\n  if (\n    tradeA.tradeType !== tradeB.tradeType ||\n    !currencyEquals(tradeA.inputAmount.currency, tradeB.inputAmount.currency) ||\n    !currencyEquals(tradeB.outputAmount.currency, tradeB.outputAmount.currency)\n  ) {\n    throw new Error('Trades are not comparable')\n  }\n\n  if (minimumDelta.equalTo(ZERO_PERCENT)) {\n    return tradeA.executionPrice.lessThan(tradeB.executionPrice)\n  } else {\n    return tradeA.executionPrice.raw.multiply(minimumDelta.add(ONE_HUNDRED_PERCENT)).lessThan(tradeB.executionPrice)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}