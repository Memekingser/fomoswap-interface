{"ast":null,"code":"import{AddressZero}from'@ethersproject/constants';import{currencyEquals,ETHER,JSBI,Pair,Percent,Route,Token,TokenAmount,Trade,TradeType,WETH}from'fomoswap-storytestnet';import{useMemo}from'react';import{useActiveWeb3React}from'../hooks';import{useAllTokens}from'../hooks/Tokens';import{useV1FactoryContract}from'../hooks/useContract';import{Version}from'../hooks/useToggledVersion';import{NEVER_RELOAD,useSingleCallResult,useSingleContractMultipleData}from'../state/multicall/hooks';import{useETHBalances,useTokenBalance,useTokenBalances}from'../state/wallet/hooks';export function useV1ExchangeAddress(tokenAddress){var _useSingleCallResult,_useSingleCallResult$;const contract=useV1FactoryContract();const inputs=useMemo(()=>[tokenAddress],[tokenAddress]);return(_useSingleCallResult=useSingleCallResult(contract,'getExchange',inputs))===null||_useSingleCallResult===void 0?void 0:(_useSingleCallResult$=_useSingleCallResult.result)===null||_useSingleCallResult$===void 0?void 0:_useSingleCallResult$[0];}export class MockV1Pair extends Pair{constructor(etherAmount,tokenAmount){super(tokenAmount,new TokenAmount(WETH[tokenAmount.token.chainId],etherAmount));}}function useMockV1Pair(inputCurrency){const token=inputCurrency instanceof Token?inputCurrency:undefined;const isWETH=Boolean(token&&token.equals(WETH[token.chainId]));const v1PairAddress=useV1ExchangeAddress(isWETH?undefined:token===null||token===void 0?void 0:token.address);const tokenBalance=useTokenBalance(v1PairAddress,token);const ETHBalance=useETHBalances([v1PairAddress])[v1PairAddress!==null&&v1PairAddress!==void 0?v1PairAddress:''];return useMemo(()=>token&&tokenBalance&&ETHBalance&&inputCurrency?new MockV1Pair(ETHBalance.raw,tokenBalance):undefined,[ETHBalance,inputCurrency,token,tokenBalance]);}// returns all v1 exchange addresses in the user's token list\nexport function useAllTokenV1Exchanges(){const allTokens=useAllTokens();const factory=useV1FactoryContract();const args=useMemo(()=>Object.keys(allTokens).map(tokenAddress=>[tokenAddress]),[allTokens]);const data=useSingleContractMultipleData(factory,'getExchange',args,NEVER_RELOAD);return useMemo(()=>{var _data$reduce;return(_data$reduce=data===null||data===void 0?void 0:data.reduce((memo,_ref,ix)=>{let{result}=_ref;if((result===null||result===void 0?void 0:result[0])&&result[0]!==AddressZero){memo[result[0]]=allTokens[args[ix][0]];}return memo;},{}))!==null&&_data$reduce!==void 0?_data$reduce:{};},[allTokens,args,data]);}// returns whether any of the tokens in the user's token list have liquidity on v1\nexport function useUserHasLiquidityInAllTokens(){const{account,chainId}=useActiveWeb3React();const exchanges=useAllTokenV1Exchanges();const v1ExchangeLiquidityTokens=useMemo(()=>chainId?Object.keys(exchanges).map(address=>new Token(chainId,address,18,'UNI-V1','Uniswap V1')):[],[chainId,exchanges]);const balances=useTokenBalances(account!==null&&account!==void 0?account:undefined,v1ExchangeLiquidityTokens);return useMemo(()=>Object.keys(balances).some(tokenAddress=>{var _balances$tokenAddres;const b=(_balances$tokenAddres=balances[tokenAddress])===null||_balances$tokenAddres===void 0?void 0:_balances$tokenAddres.raw;return b&&JSBI.greaterThan(b,JSBI.BigInt(0));}),[balances]);}/**\n * Returns the trade to execute on V1 to go between input and output token\n */export function useV1Trade(isExactIn,inputCurrency,outputCurrency,exactAmount){// get the mock v1 pairs\nconst inputPair=useMockV1Pair(inputCurrency);const outputPair=useMockV1Pair(outputCurrency);const inputIsETH=inputCurrency===ETHER;const outputIsETH=outputCurrency===ETHER;// construct a direct or through ETH v1 route\nlet pairs=[];if(inputIsETH&&outputPair){pairs=[outputPair];}else if(outputIsETH&&inputPair){pairs=[inputPair];}// if neither are ETH, it's token-to-token (if they both exist)\nelse if(inputPair&&outputPair){pairs=[inputPair,outputPair];}const route=inputCurrency&&pairs&&pairs.length>0&&new Route(pairs,inputCurrency,outputCurrency);let v1Trade;try{v1Trade=route&&exactAmount?new Trade(route,exactAmount,isExactIn?TradeType.EXACT_INPUT:TradeType.EXACT_OUTPUT):undefined;}catch(error){console.debug('Failed to create V1 trade',error);}return v1Trade;}export function getTradeVersion(trade){var _trade$route,_trade$route$pairs;const isV1=trade===null||trade===void 0?void 0:(_trade$route=trade.route)===null||_trade$route===void 0?void 0:(_trade$route$pairs=_trade$route.pairs)===null||_trade$route$pairs===void 0?void 0:_trade$route$pairs.some(pair=>pair instanceof MockV1Pair);if(isV1)return Version.v1;if(isV1===false)return Version.v2;return undefined;}// returns the v1 exchange against which a trade should be executed\nexport function useV1TradeExchangeAddress(trade){const tokenAddress=useMemo(()=>{if(!trade)return undefined;const isV1=getTradeVersion(trade)===Version.v1;if(!isV1)return undefined;return trade.inputAmount instanceof TokenAmount?trade.inputAmount.token.address:trade.outputAmount instanceof TokenAmount?trade.outputAmount.token.address:undefined;},[trade]);return useV1ExchangeAddress(tokenAddress);}const ZERO_PERCENT=new Percent('0');const ONE_HUNDRED_PERCENT=new Percent('1');// returns whether tradeB is better than tradeA by at least a threshold percentage amount\nexport function isTradeBetter(tradeA,tradeB){let minimumDelta=arguments.length>2&&arguments[2]!==undefined?arguments[2]:ZERO_PERCENT;if(!tradeA||!tradeB)return undefined;if(tradeA.tradeType!==tradeB.tradeType||!currencyEquals(tradeA.inputAmount.currency,tradeB.inputAmount.currency)||!currencyEquals(tradeB.outputAmount.currency,tradeB.outputAmount.currency)){throw new Error('Trades are not comparable');}if(minimumDelta.equalTo(ZERO_PERCENT)){return tradeA.executionPrice.lessThan(tradeB.executionPrice);}else{return tradeA.executionPrice.raw.multiply(minimumDelta.add(ONE_HUNDRED_PERCENT)).lessThan(tradeB.executionPrice);}}","map":{"version":3,"names":["AddressZero","currencyEquals","ETHER","JSBI","Pair","Percent","Route","Token","TokenAmount","Trade","TradeType","WETH","useMemo","useActiveWeb3React","useAllTokens","useV1FactoryContract","Version","NEVER_RELOAD","useSingleCallResult","useSingleContractMultipleData","useETHBalances","useTokenBalance","useTokenBalances","useV1ExchangeAddress","tokenAddress","_useSingleCallResult","_useSingleCallResult$","contract","inputs","result","MockV1Pair","constructor","etherAmount","tokenAmount","token","chainId","useMockV1Pair","inputCurrency","undefined","isWETH","Boolean","equals","v1PairAddress","address","tokenBalance","ETHBalance","raw","useAllTokenV1Exchanges","allTokens","factory","args","Object","keys","map","data","_data$reduce","reduce","memo","_ref","ix","useUserHasLiquidityInAllTokens","account","exchanges","v1ExchangeLiquidityTokens","balances","some","_balances$tokenAddres","b","greaterThan","BigInt","useV1Trade","isExactIn","outputCurrency","exactAmount","inputPair","outputPair","inputIsETH","outputIsETH","pairs","route","length","v1Trade","EXACT_INPUT","EXACT_OUTPUT","error","console","debug","getTradeVersion","trade","_trade$route","_trade$route$pairs","isV1","pair","v1","v2","useV1TradeExchangeAddress","inputAmount","outputAmount","ZERO_PERCENT","ONE_HUNDRED_PERCENT","isTradeBetter","tradeA","tradeB","minimumDelta","arguments","tradeType","currency","Error","equalTo","executionPrice","lessThan","multiply","add"],"sources":["/Users/synallage/Desktop/fomoswap-uni/interface-73580de922ce3ff642430d71aa24f5c053e6dd4d/src/data/V1.ts"],"sourcesContent":["import { AddressZero } from '@ethersproject/constants'\nimport {\n  BigintIsh,\n  Currency,\n  CurrencyAmount,\n  currencyEquals,\n  ETHER,\n  JSBI,\n  Pair,\n  Percent,\n  Route,\n  Token,\n  TokenAmount,\n  Trade,\n  TradeType,\n  WETH\n} from 'fomoswap-storytestnet'\nimport { useMemo } from 'react'\nimport { useActiveWeb3React } from '../hooks'\nimport { useAllTokens } from '../hooks/Tokens'\nimport { useV1FactoryContract } from '../hooks/useContract'\nimport { Version } from '../hooks/useToggledVersion'\nimport { NEVER_RELOAD, useSingleCallResult, useSingleContractMultipleData } from '../state/multicall/hooks'\nimport { useETHBalances, useTokenBalance, useTokenBalances } from '../state/wallet/hooks'\n\nexport function useV1ExchangeAddress(tokenAddress?: string): string | undefined {\n  const contract = useV1FactoryContract()\n\n  const inputs = useMemo(() => [tokenAddress], [tokenAddress])\n  return useSingleCallResult(contract, 'getExchange', inputs)?.result?.[0]\n}\n\nexport class MockV1Pair extends Pair {\n  constructor(etherAmount: BigintIsh, tokenAmount: TokenAmount) {\n    super(tokenAmount, new TokenAmount(WETH[tokenAmount.token.chainId], etherAmount))\n  }\n}\n\nfunction useMockV1Pair(inputCurrency?: Currency): MockV1Pair | undefined {\n  const token = inputCurrency instanceof Token ? inputCurrency : undefined\n\n  const isWETH = Boolean(token && token.equals(WETH[token.chainId]))\n  const v1PairAddress = useV1ExchangeAddress(isWETH ? undefined : token?.address)\n  const tokenBalance = useTokenBalance(v1PairAddress, token)\n  const ETHBalance = useETHBalances([v1PairAddress])[v1PairAddress ?? '']\n\n  return useMemo(\n    () =>\n      token && tokenBalance && ETHBalance && inputCurrency ? new MockV1Pair(ETHBalance.raw, tokenBalance) : undefined,\n    [ETHBalance, inputCurrency, token, tokenBalance]\n  )\n}\n\n// returns all v1 exchange addresses in the user's token list\nexport function useAllTokenV1Exchanges(): { [exchangeAddress: string]: Token } {\n  const allTokens = useAllTokens()\n  const factory = useV1FactoryContract()\n  const args = useMemo(() => Object.keys(allTokens).map(tokenAddress => [tokenAddress]), [allTokens])\n\n  const data = useSingleContractMultipleData(factory, 'getExchange', args, NEVER_RELOAD)\n\n  return useMemo(\n    () =>\n      data?.reduce<{ [exchangeAddress: string]: Token }>((memo, { result }, ix) => {\n        if (result?.[0] && result[0] !== AddressZero) {\n          memo[result[0]] = allTokens[args[ix][0]]\n        }\n        return memo\n      }, {}) ?? {},\n    [allTokens, args, data]\n  )\n}\n\n// returns whether any of the tokens in the user's token list have liquidity on v1\nexport function useUserHasLiquidityInAllTokens(): boolean | undefined {\n  const { account, chainId } = useActiveWeb3React()\n\n  const exchanges = useAllTokenV1Exchanges()\n\n  const v1ExchangeLiquidityTokens = useMemo(\n    () =>\n      chainId ? Object.keys(exchanges).map(address => new Token(chainId, address, 18, 'UNI-V1', 'Uniswap V1')) : [],\n    [chainId, exchanges]\n  )\n\n  const balances = useTokenBalances(account ?? undefined, v1ExchangeLiquidityTokens)\n\n  return useMemo(\n    () =>\n      Object.keys(balances).some(tokenAddress => {\n        const b = balances[tokenAddress]?.raw\n        return b && JSBI.greaterThan(b, JSBI.BigInt(0))\n      }),\n    [balances]\n  )\n}\n\n/**\n * Returns the trade to execute on V1 to go between input and output token\n */\nexport function useV1Trade(\n  isExactIn?: boolean,\n  inputCurrency?: Currency,\n  outputCurrency?: Currency,\n  exactAmount?: CurrencyAmount\n): Trade | undefined {\n  // get the mock v1 pairs\n  const inputPair = useMockV1Pair(inputCurrency)\n  const outputPair = useMockV1Pair(outputCurrency)\n\n  const inputIsETH = inputCurrency === ETHER\n  const outputIsETH = outputCurrency === ETHER\n\n  // construct a direct or through ETH v1 route\n  let pairs: Pair[] = []\n  if (inputIsETH && outputPair) {\n    pairs = [outputPair]\n  } else if (outputIsETH && inputPair) {\n    pairs = [inputPair]\n  }\n  // if neither are ETH, it's token-to-token (if they both exist)\n  else if (inputPair && outputPair) {\n    pairs = [inputPair, outputPair]\n  }\n\n  const route = inputCurrency && pairs && pairs.length > 0 && new Route(pairs, inputCurrency, outputCurrency)\n  let v1Trade: Trade | undefined\n  try {\n    v1Trade =\n      route && exactAmount\n        ? new Trade(route, exactAmount, isExactIn ? TradeType.EXACT_INPUT : TradeType.EXACT_OUTPUT)\n        : undefined\n  } catch (error) {\n    console.debug('Failed to create V1 trade', error)\n  }\n  return v1Trade\n}\n\nexport function getTradeVersion(trade?: Trade): Version | undefined {\n  const isV1 = trade?.route?.pairs?.some(pair => pair instanceof MockV1Pair)\n  if (isV1) return Version.v1\n  if (isV1 === false) return Version.v2\n  return undefined\n}\n\n// returns the v1 exchange against which a trade should be executed\nexport function useV1TradeExchangeAddress(trade: Trade | undefined): string | undefined {\n  const tokenAddress: string | undefined = useMemo(() => {\n    if (!trade) return undefined\n    const isV1 = getTradeVersion(trade) === Version.v1\n    if (!isV1) return undefined\n    return trade.inputAmount instanceof TokenAmount\n      ? trade.inputAmount.token.address\n      : trade.outputAmount instanceof TokenAmount\n      ? trade.outputAmount.token.address\n      : undefined\n  }, [trade])\n  return useV1ExchangeAddress(tokenAddress)\n}\n\nconst ZERO_PERCENT = new Percent('0')\nconst ONE_HUNDRED_PERCENT = new Percent('1')\n\n// returns whether tradeB is better than tradeA by at least a threshold percentage amount\nexport function isTradeBetter(\n  tradeA: Trade | undefined,\n  tradeB: Trade | undefined,\n  minimumDelta: Percent = ZERO_PERCENT\n): boolean | undefined {\n  if (!tradeA || !tradeB) return undefined\n\n  if (\n    tradeA.tradeType !== tradeB.tradeType ||\n    !currencyEquals(tradeA.inputAmount.currency, tradeB.inputAmount.currency) ||\n    !currencyEquals(tradeB.outputAmount.currency, tradeB.outputAmount.currency)\n  ) {\n    throw new Error('Trades are not comparable')\n  }\n\n  if (minimumDelta.equalTo(ZERO_PERCENT)) {\n    return tradeA.executionPrice.lessThan(tradeB.executionPrice)\n  } else {\n    return tradeA.executionPrice.raw.multiply(minimumDelta.add(ONE_HUNDRED_PERCENT)).lessThan(tradeB.executionPrice)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}