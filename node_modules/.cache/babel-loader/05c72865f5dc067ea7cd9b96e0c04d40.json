{"ast":null,"code":"import { parseBytes32String } from '@ethersproject/strings';\nimport { ETHER, Token } from 'fomoswap-bera1';\nimport { useMemo } from 'react';\nimport { useDefaultTokenList } from '../state/lists/hooks';\nimport { NEVER_RELOAD, useSingleCallResult } from '../state/multicall/hooks';\nimport { useUserAddedTokens } from '../state/user/hooks';\nimport { isAddress } from '../utils';\nimport { useActiveWeb3React } from './index';\nimport { useBytes32TokenContract, useTokenContract } from './useContract';\nexport function useAllTokens() {\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const userAddedTokens = useUserAddedTokens();\n  const allTokens = useDefaultTokenList();\n  return useMemo(() => {\n    if (!chainId) return {};\n    return userAddedTokens\n    // reduce into all ALL_TOKENS filtered by the current chain\n    .reduce((tokenMap, token) => {\n      tokenMap[token.address] = token;\n      return tokenMap;\n    },\n    // must make a copy because reduce modifies the map, and we do not\n    // want to make a copy in every iteration\n    {\n      ...allTokens[chainId]\n    });\n  }, [chainId, userAddedTokens, allTokens]);\n}\n\n// parse a name or symbol from a token response\nconst BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/;\nfunction parseStringOrBytes32(str, bytes32, defaultValue) {\n  return str && str.length > 0 ? str : bytes32 && BYTES32_REGEX.test(bytes32) ? parseBytes32String(bytes32) : defaultValue;\n}\n\n// undefined if invalid or does not exist\n// null if loading\n// otherwise returns the token\nexport function useToken(tokenAddress) {\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const tokens = useAllTokens();\n  const address = isAddress(tokenAddress);\n  const tokenContract = useTokenContract(address ? address : undefined, false);\n  const tokenContractBytes32 = useBytes32TokenContract(address ? address : undefined, false);\n  const token = address ? tokens[address] : undefined;\n  const tokenName = useSingleCallResult(token ? undefined : tokenContract, 'name', undefined, NEVER_RELOAD);\n  const tokenNameBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'name', undefined, NEVER_RELOAD);\n  const symbol = useSingleCallResult(token ? undefined : tokenContract, 'symbol', undefined, NEVER_RELOAD);\n  const symbolBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'symbol', undefined, NEVER_RELOAD);\n  const decimals = useSingleCallResult(token ? undefined : tokenContract, 'decimals', undefined, NEVER_RELOAD);\n  return useMemo(() => {\n    if (token) return token;\n    if (!chainId || !address) return undefined;\n    if (decimals.loading || symbol.loading || tokenName.loading) return null;\n    if (decimals.result) {\n      var _symbol$result, _symbolBytes32$result, _tokenName$result, _tokenNameBytes32$res;\n      return new Token(chainId, address, decimals.result[0], parseStringOrBytes32((_symbol$result = symbol.result) === null || _symbol$result === void 0 ? void 0 : _symbol$result[0], (_symbolBytes32$result = symbolBytes32.result) === null || _symbolBytes32$result === void 0 ? void 0 : _symbolBytes32$result[0], 'UNKNOWN'), parseStringOrBytes32((_tokenName$result = tokenName.result) === null || _tokenName$result === void 0 ? void 0 : _tokenName$result[0], (_tokenNameBytes32$res = tokenNameBytes32.result) === null || _tokenNameBytes32$res === void 0 ? void 0 : _tokenNameBytes32$res[0], 'Unknown Token'));\n    }\n    return undefined;\n  }, [address, chainId, decimals.loading, decimals.result, symbol.loading, symbol.result, symbolBytes32.result, token, tokenName.loading, tokenName.result, tokenNameBytes32.result]);\n}\nexport function useCurrency(currencyId) {\n  const isETH = (currencyId === null || currencyId === void 0 ? void 0 : currencyId.toUpperCase()) === 'ETH';\n  const token = useToken(isETH ? undefined : currencyId);\n  return isETH ? ETHER : token;\n}","map":{"version":3,"names":["parseBytes32String","ETHER","Token","useMemo","useDefaultTokenList","NEVER_RELOAD","useSingleCallResult","useUserAddedTokens","isAddress","useActiveWeb3React","useBytes32TokenContract","useTokenContract","useAllTokens","chainId","userAddedTokens","allTokens","reduce","tokenMap","token","address","BYTES32_REGEX","parseStringOrBytes32","str","bytes32","defaultValue","length","test","useToken","tokenAddress","tokens","tokenContract","undefined","tokenContractBytes32","tokenName","tokenNameBytes32","symbol","symbolBytes32","decimals","loading","result","_symbol$result","_symbolBytes32$result","_tokenName$result","_tokenNameBytes32$res","useCurrency","currencyId","isETH","toUpperCase"],"sources":["/Users/synallage/Desktop/fomoswap-uni/interface-73580de922ce3ff642430d71aa24f5c053e6dd4d/src/hooks/Tokens.ts"],"sourcesContent":["import { parseBytes32String } from '@ethersproject/strings'\nimport { Currency, ETHER, Token } from 'fomoswap-bera1'\nimport { useMemo } from 'react'\nimport { useDefaultTokenList } from '../state/lists/hooks'\nimport { NEVER_RELOAD, useSingleCallResult } from '../state/multicall/hooks'\nimport { useUserAddedTokens } from '../state/user/hooks'\nimport { isAddress } from '../utils'\n\nimport { useActiveWeb3React } from './index'\nimport { useBytes32TokenContract, useTokenContract } from './useContract'\n\nexport function useAllTokens(): { [address: string]: Token } {\n  const { chainId } = useActiveWeb3React()\n  const userAddedTokens = useUserAddedTokens()\n  const allTokens = useDefaultTokenList()\n\n  return useMemo(() => {\n    if (!chainId) return {}\n    return (\n      userAddedTokens\n        // reduce into all ALL_TOKENS filtered by the current chain\n        .reduce<{ [address: string]: Token }>(\n          (tokenMap, token) => {\n            tokenMap[token.address] = token\n            return tokenMap\n          },\n          // must make a copy because reduce modifies the map, and we do not\n          // want to make a copy in every iteration\n          { ...allTokens[chainId] }\n        )\n    )\n  }, [chainId, userAddedTokens, allTokens])\n}\n\n// parse a name or symbol from a token response\nconst BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/\nfunction parseStringOrBytes32(str: string | undefined, bytes32: string | undefined, defaultValue: string): string {\n  return str && str.length > 0\n    ? str\n    : bytes32 && BYTES32_REGEX.test(bytes32)\n    ? parseBytes32String(bytes32)\n    : defaultValue\n}\n\n// undefined if invalid or does not exist\n// null if loading\n// otherwise returns the token\nexport function useToken(tokenAddress?: string): Token | undefined | null {\n  const { chainId } = useActiveWeb3React()\n  const tokens = useAllTokens()\n\n  const address = isAddress(tokenAddress)\n\n  const tokenContract = useTokenContract(address ? address : undefined, false)\n  const tokenContractBytes32 = useBytes32TokenContract(address ? address : undefined, false)\n  const token: Token | undefined = address ? tokens[address] : undefined\n\n  const tokenName = useSingleCallResult(token ? undefined : tokenContract, 'name', undefined, NEVER_RELOAD)\n  const tokenNameBytes32 = useSingleCallResult(\n    token ? undefined : tokenContractBytes32,\n    'name',\n    undefined,\n    NEVER_RELOAD\n  )\n  const symbol = useSingleCallResult(token ? undefined : tokenContract, 'symbol', undefined, NEVER_RELOAD)\n  const symbolBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'symbol', undefined, NEVER_RELOAD)\n  const decimals = useSingleCallResult(token ? undefined : tokenContract, 'decimals', undefined, NEVER_RELOAD)\n\n  return useMemo(() => {\n    if (token) return token\n    if (!chainId || !address) return undefined\n    if (decimals.loading || symbol.loading || tokenName.loading) return null\n    if (decimals.result) {\n      return new Token(\n        chainId,\n        address,\n        decimals.result[0],\n        parseStringOrBytes32(symbol.result?.[0], symbolBytes32.result?.[0], 'UNKNOWN'),\n        parseStringOrBytes32(tokenName.result?.[0], tokenNameBytes32.result?.[0], 'Unknown Token')\n      )\n    }\n    return undefined\n  }, [\n    address,\n    chainId,\n    decimals.loading,\n    decimals.result,\n    symbol.loading,\n    symbol.result,\n    symbolBytes32.result,\n    token,\n    tokenName.loading,\n    tokenName.result,\n    tokenNameBytes32.result\n  ])\n}\n\nexport function useCurrency(currencyId: string | undefined): Currency | null | undefined {\n  const isETH = currencyId?.toUpperCase() === 'ETH'\n  const token = useToken(isETH ? undefined : currencyId)\n  return isETH ? ETHER : token\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}