{"ast":null,"code":"import { CurrencyAmount, ETHER, JSBI, Percent, Price } from 'fomoswap-storytestnet';\nimport { useCallback, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { PairState, usePair } from '../../data/Reserves';\nimport { useTotalSupply } from '../../data/TotalSupply';\nimport { useActiveWeb3React } from '../../hooks';\nimport { wrappedCurrency, wrappedCurrencyAmount } from '../../utils/wrappedCurrency';\nimport { tryParseAmount } from '../swap/hooks';\nimport { useCurrencyBalances } from '../wallet/hooks';\nimport { Field, typeInput } from './actions';\nconst ZERO = JSBI.BigInt(0);\nexport function useMintState() {\n  return useSelector(state => state.mint);\n}\nexport function useDerivedMintInfo(currencyA, currencyB) {\n  var _currencyBalances$Fie, _currencyBalances$Fie2;\n  const {\n    account,\n    chainId\n  } = useActiveWeb3React();\n  const {\n    independentField,\n    typedValue,\n    otherTypedValue\n  } = useMintState();\n  const dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A;\n\n  // tokens\n  const currencies = useMemo(() => ({\n    [Field.CURRENCY_A]: currencyA !== null && currencyA !== void 0 ? currencyA : undefined,\n    [Field.CURRENCY_B]: currencyB !== null && currencyB !== void 0 ? currencyB : undefined\n  }), [currencyA, currencyB]);\n\n  // pair\n  const [pairState, pair] = usePair(currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]);\n  const totalSupply = useTotalSupply(pair === null || pair === void 0 ? void 0 : pair.liquidityToken);\n  const noLiquidity = pairState === PairState.NOT_EXISTS || Boolean(totalSupply && JSBI.equal(totalSupply.raw, ZERO));\n\n  // balances\n  const balances = useCurrencyBalances(account !== null && account !== void 0 ? account : undefined, [currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]]);\n  const currencyBalances = {\n    [Field.CURRENCY_A]: balances[0],\n    [Field.CURRENCY_B]: balances[1]\n  };\n\n  // amounts\n  const independentAmount = tryParseAmount(typedValue, currencies[independentField]);\n  const dependentAmount = useMemo(() => {\n    if (noLiquidity) {\n      if (otherTypedValue && currencies[dependentField]) {\n        return tryParseAmount(otherTypedValue, currencies[dependentField]);\n      }\n      return;\n    } else if (independentAmount) {\n      // we wrap the currencies just to get the price in terms of the other token\n      const wrappedIndependentAmount = wrappedCurrencyAmount(independentAmount, chainId);\n      const [tokenA, tokenB] = [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)];\n      if (tokenA && tokenB && wrappedIndependentAmount && pair) {\n        const dependentCurrency = dependentField === Field.CURRENCY_B ? currencyB : currencyA;\n        const dependentTokenAmount = dependentField === Field.CURRENCY_B ? pair.priceOf(tokenA).quote(wrappedIndependentAmount) : pair.priceOf(tokenB).quote(wrappedIndependentAmount);\n        return dependentCurrency === ETHER ? CurrencyAmount.ether(dependentTokenAmount.raw) : dependentTokenAmount;\n      }\n      return;\n    } else {\n      return;\n    }\n  }, [noLiquidity, otherTypedValue, currencies, dependentField, independentAmount, currencyA, chainId, currencyB, pair]);\n  const parsedAmounts = {\n    [Field.CURRENCY_A]: independentField === Field.CURRENCY_A ? independentAmount : dependentAmount,\n    [Field.CURRENCY_B]: independentField === Field.CURRENCY_A ? dependentAmount : independentAmount\n  };\n  const token0Price = pair === null || pair === void 0 ? void 0 : pair.token0Price;\n  const price = useMemo(() => {\n    if (noLiquidity) {\n      const {\n        [Field.CURRENCY_A]: currencyAAmount,\n        [Field.CURRENCY_B]: currencyBAmount\n      } = parsedAmounts;\n      if (currencyAAmount && currencyBAmount) {\n        return new Price(currencyAAmount.currency, currencyBAmount.currency, currencyAAmount.raw, currencyBAmount.raw);\n      }\n      return;\n    } else {\n      return token0Price;\n    }\n  }, [noLiquidity, token0Price, parsedAmounts]);\n\n  // liquidity minted\n  const liquidityMinted = useMemo(() => {\n    const {\n      [Field.CURRENCY_A]: currencyAAmount,\n      [Field.CURRENCY_B]: currencyBAmount\n    } = parsedAmounts;\n    const [tokenAmountA, tokenAmountB] = [wrappedCurrencyAmount(currencyAAmount, chainId), wrappedCurrencyAmount(currencyBAmount, chainId)];\n    if (pair && totalSupply && tokenAmountA && tokenAmountB) {\n      return pair.getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB);\n    } else {\n      return;\n    }\n  }, [parsedAmounts, chainId, pair, totalSupply]);\n  const poolTokenPercentage = useMemo(() => {\n    if (liquidityMinted && totalSupply) {\n      return new Percent(liquidityMinted.raw, totalSupply.add(liquidityMinted).raw);\n    } else {\n      return;\n    }\n  }, [liquidityMinted, totalSupply]);\n  let error;\n  if (!account) {\n    error = 'Connect Wallet';\n  }\n  if (pairState === PairState.INVALID) {\n    var _error;\n    error = (_error = error) !== null && _error !== void 0 ? _error : 'Invalid pair';\n  }\n  if (!parsedAmounts[Field.CURRENCY_A] || !parsedAmounts[Field.CURRENCY_B]) {\n    var _error2;\n    error = (_error2 = error) !== null && _error2 !== void 0 ? _error2 : 'Enter an amount';\n  }\n  const {\n    [Field.CURRENCY_A]: currencyAAmount,\n    [Field.CURRENCY_B]: currencyBAmount\n  } = parsedAmounts;\n  if (currencyAAmount && (currencyBalances === null || currencyBalances === void 0 ? void 0 : (_currencyBalances$Fie = currencyBalances[Field.CURRENCY_A]) === null || _currencyBalances$Fie === void 0 ? void 0 : _currencyBalances$Fie.lessThan(currencyAAmount))) {\n    var _currencies$Field$CUR;\n    error = 'Insufficient ' + ((_currencies$Field$CUR = currencies[Field.CURRENCY_A]) === null || _currencies$Field$CUR === void 0 ? void 0 : _currencies$Field$CUR.symbol) + ' balance';\n  }\n  if (currencyBAmount && (currencyBalances === null || currencyBalances === void 0 ? void 0 : (_currencyBalances$Fie2 = currencyBalances[Field.CURRENCY_B]) === null || _currencyBalances$Fie2 === void 0 ? void 0 : _currencyBalances$Fie2.lessThan(currencyBAmount))) {\n    var _currencies$Field$CUR2;\n    error = 'Insufficient ' + ((_currencies$Field$CUR2 = currencies[Field.CURRENCY_B]) === null || _currencies$Field$CUR2 === void 0 ? void 0 : _currencies$Field$CUR2.symbol) + ' balance';\n  }\n  return {\n    dependentField,\n    currencies,\n    pair,\n    pairState,\n    currencyBalances,\n    parsedAmounts,\n    price,\n    noLiquidity,\n    liquidityMinted,\n    poolTokenPercentage,\n    error\n  };\n}\nexport function useMintActionHandlers(noLiquidity) {\n  const dispatch = useDispatch();\n  const onFieldAInput = useCallback(typedValue => {\n    dispatch(typeInput({\n      field: Field.CURRENCY_A,\n      typedValue,\n      noLiquidity: noLiquidity === true\n    }));\n  }, [dispatch, noLiquidity]);\n  const onFieldBInput = useCallback(typedValue => {\n    dispatch(typeInput({\n      field: Field.CURRENCY_B,\n      typedValue,\n      noLiquidity: noLiquidity === true\n    }));\n  }, [dispatch, noLiquidity]);\n  return {\n    onFieldAInput,\n    onFieldBInput\n  };\n}","map":{"version":3,"names":["CurrencyAmount","ETHER","JSBI","Percent","Price","useCallback","useMemo","useDispatch","useSelector","PairState","usePair","useTotalSupply","useActiveWeb3React","wrappedCurrency","wrappedCurrencyAmount","tryParseAmount","useCurrencyBalances","Field","typeInput","ZERO","BigInt","useMintState","state","mint","useDerivedMintInfo","currencyA","currencyB","_currencyBalances$Fie","_currencyBalances$Fie2","account","chainId","independentField","typedValue","otherTypedValue","dependentField","CURRENCY_A","CURRENCY_B","currencies","undefined","pairState","pair","totalSupply","liquidityToken","noLiquidity","NOT_EXISTS","Boolean","equal","raw","balances","currencyBalances","independentAmount","dependentAmount","wrappedIndependentAmount","tokenA","tokenB","dependentCurrency","dependentTokenAmount","priceOf","quote","ether","parsedAmounts","token0Price","price","currencyAAmount","currencyBAmount","currency","liquidityMinted","tokenAmountA","tokenAmountB","getLiquidityMinted","poolTokenPercentage","add","error","INVALID","_error","_error2","lessThan","_currencies$Field$CUR","symbol","_currencies$Field$CUR2","useMintActionHandlers","dispatch","onFieldAInput","field","onFieldBInput"],"sources":["/Users/synallage/Desktop/fomoswap-uni/interface-73580de922ce3ff642430d71aa24f5c053e6dd4d/src/state/mint/hooks.ts"],"sourcesContent":["import { Currency, CurrencyAmount, ETHER, JSBI, Pair, Percent, Price, TokenAmount } from 'fomoswap-storytestnet'\nimport { useCallback, useMemo } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\nimport { PairState, usePair } from '../../data/Reserves'\nimport { useTotalSupply } from '../../data/TotalSupply'\n\nimport { useActiveWeb3React } from '../../hooks'\nimport { wrappedCurrency, wrappedCurrencyAmount } from '../../utils/wrappedCurrency'\nimport { AppDispatch, AppState } from '../index'\nimport { tryParseAmount } from '../swap/hooks'\nimport { useCurrencyBalances } from '../wallet/hooks'\nimport { Field, typeInput } from './actions'\n\nconst ZERO = JSBI.BigInt(0)\n\nexport function useMintState(): AppState['mint'] {\n  return useSelector<AppState, AppState['mint']>(state => state.mint)\n}\n\nexport function useDerivedMintInfo(\n  currencyA: Currency | undefined,\n  currencyB: Currency | undefined\n): {\n  dependentField: Field\n  currencies: { [field in Field]?: Currency }\n  pair?: Pair | null\n  pairState: PairState\n  currencyBalances: { [field in Field]?: CurrencyAmount }\n  parsedAmounts: { [field in Field]?: CurrencyAmount }\n  price?: Price\n  noLiquidity?: boolean\n  liquidityMinted?: TokenAmount\n  poolTokenPercentage?: Percent\n  error?: string\n} {\n  const { account, chainId } = useActiveWeb3React()\n\n  const { independentField, typedValue, otherTypedValue } = useMintState()\n\n  const dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A\n\n  // tokens\n  const currencies: { [field in Field]?: Currency } = useMemo(\n    () => ({\n      [Field.CURRENCY_A]: currencyA ?? undefined,\n      [Field.CURRENCY_B]: currencyB ?? undefined\n    }),\n    [currencyA, currencyB]\n  )\n\n  // pair\n  const [pairState, pair] = usePair(currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B])\n  const totalSupply = useTotalSupply(pair?.liquidityToken)\n\n  const noLiquidity: boolean =\n    pairState === PairState.NOT_EXISTS || Boolean(totalSupply && JSBI.equal(totalSupply.raw, ZERO))\n\n  // balances\n  const balances = useCurrencyBalances(account ?? undefined, [\n    currencies[Field.CURRENCY_A],\n    currencies[Field.CURRENCY_B]\n  ])\n  const currencyBalances: { [field in Field]?: CurrencyAmount } = {\n    [Field.CURRENCY_A]: balances[0],\n    [Field.CURRENCY_B]: balances[1]\n  }\n\n  // amounts\n  const independentAmount: CurrencyAmount | undefined = tryParseAmount(typedValue, currencies[independentField])\n  const dependentAmount: CurrencyAmount | undefined = useMemo(() => {\n    if (noLiquidity) {\n      if (otherTypedValue && currencies[dependentField]) {\n        return tryParseAmount(otherTypedValue, currencies[dependentField])\n      }\n      return\n    } else if (independentAmount) {\n      // we wrap the currencies just to get the price in terms of the other token\n      const wrappedIndependentAmount = wrappedCurrencyAmount(independentAmount, chainId)\n      const [tokenA, tokenB] = [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)]\n      if (tokenA && tokenB && wrappedIndependentAmount && pair) {\n        const dependentCurrency = dependentField === Field.CURRENCY_B ? currencyB : currencyA\n        const dependentTokenAmount =\n          dependentField === Field.CURRENCY_B\n            ? pair.priceOf(tokenA).quote(wrappedIndependentAmount)\n            : pair.priceOf(tokenB).quote(wrappedIndependentAmount)\n        return dependentCurrency === ETHER ? CurrencyAmount.ether(dependentTokenAmount.raw) : dependentTokenAmount\n      }\n      return\n    } else {\n      return\n    }\n  }, [noLiquidity, otherTypedValue, currencies, dependentField, independentAmount, currencyA, chainId, currencyB, pair])\n  const parsedAmounts: { [field in Field]: CurrencyAmount | undefined } = {\n    [Field.CURRENCY_A]: independentField === Field.CURRENCY_A ? independentAmount : dependentAmount,\n    [Field.CURRENCY_B]: independentField === Field.CURRENCY_A ? dependentAmount : independentAmount\n  }\n\n  const token0Price = pair?.token0Price\n  const price = useMemo(() => {\n    if (noLiquidity) {\n      const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts\n      if (currencyAAmount && currencyBAmount) {\n        return new Price(currencyAAmount.currency, currencyBAmount.currency, currencyAAmount.raw, currencyBAmount.raw)\n      }\n      return\n    } else {\n      return token0Price\n    }\n  }, [noLiquidity, token0Price, parsedAmounts])\n\n  // liquidity minted\n  const liquidityMinted = useMemo(() => {\n    const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts\n    const [tokenAmountA, tokenAmountB] = [\n      wrappedCurrencyAmount(currencyAAmount, chainId),\n      wrappedCurrencyAmount(currencyBAmount, chainId)\n    ]\n    if (pair && totalSupply && tokenAmountA && tokenAmountB) {\n      return pair.getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB)\n    } else {\n      return\n    }\n  }, [parsedAmounts, chainId, pair, totalSupply])\n\n  const poolTokenPercentage = useMemo(() => {\n    if (liquidityMinted && totalSupply) {\n      return new Percent(liquidityMinted.raw, totalSupply.add(liquidityMinted).raw)\n    } else {\n      return\n    }\n  }, [liquidityMinted, totalSupply])\n\n  let error: string | undefined\n  if (!account) {\n    error = 'Connect Wallet'\n  }\n\n  if (pairState === PairState.INVALID) {\n    error = error ?? 'Invalid pair'\n  }\n\n  if (!parsedAmounts[Field.CURRENCY_A] || !parsedAmounts[Field.CURRENCY_B]) {\n    error = error ?? 'Enter an amount'\n  }\n\n  const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts\n\n  if (currencyAAmount && currencyBalances?.[Field.CURRENCY_A]?.lessThan(currencyAAmount)) {\n    error = 'Insufficient ' + currencies[Field.CURRENCY_A]?.symbol + ' balance'\n  }\n\n  if (currencyBAmount && currencyBalances?.[Field.CURRENCY_B]?.lessThan(currencyBAmount)) {\n    error = 'Insufficient ' + currencies[Field.CURRENCY_B]?.symbol + ' balance'\n  }\n\n  return {\n    dependentField,\n    currencies,\n    pair,\n    pairState,\n    currencyBalances,\n    parsedAmounts,\n    price,\n    noLiquidity,\n    liquidityMinted,\n    poolTokenPercentage,\n    error\n  }\n}\n\nexport function useMintActionHandlers(\n  noLiquidity: boolean | undefined\n): {\n  onFieldAInput: (typedValue: string) => void\n  onFieldBInput: (typedValue: string) => void\n} {\n  const dispatch = useDispatch<AppDispatch>()\n\n  const onFieldAInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeInput({ field: Field.CURRENCY_A, typedValue, noLiquidity: noLiquidity === true }))\n    },\n    [dispatch, noLiquidity]\n  )\n  const onFieldBInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeInput({ field: Field.CURRENCY_B, typedValue, noLiquidity: noLiquidity === true }))\n    },\n    [dispatch, noLiquidity]\n  )\n\n  return {\n    onFieldAInput,\n    onFieldBInput\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}